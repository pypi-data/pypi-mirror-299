[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "extended-data-types"
dynamic = ["version"]
description = "Extended functionality for data types"
requires-python = ">=3.9"
license = "MIT"
readme = "README.md"
keywords = ["python3"]
authors = [{ name = "Jon Bogaty", email = "jon@jonbogaty.com" }]
maintainers = [{ name = "Jon Bogaty", email = "jon@jonbogaty.com" }]
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Typing :: Typed",
]
dependencies = [
    "future>=1.0.0",
    "inflection>=0.5.1",
    "orjson>=3.10.7",
    "python-hcl2>=4.3.4",
    "pyyaml>=6.0.1",
    "requests>=2.32.3",
    "sortedcontainers>=2.4.0",
    "tomlkit>=0.13.2",
    "wrapt>=1.16.0",
]

[project.urls]
Documentation = "https://github.com/jbcom/extended-data-types#readme"
Issues = "https://github.com/jbcom/extended-data-types/issues"
Source = "https://github.com/jbcom/extended-data-types"

[project.optional-dependencies]
tests = [
    "pytest>=8.2.2",
    "pytest-cov>=5.0.0",
    "pytest-mock>=3.14.0",
    "pytest-xdist>=3.6.1",
    "coverage[toml]>=7.6.0",
]

typing = [
    "mypy>=1.0.0",
    "types-PyYAML>=6.0.12.20240724",
    "sortedcontainers-stubs>=2.4.2",
]

docs = [
    "sphinx>=7.2,<7.5",
    "sphinxawesome-theme>=5.2.0",
    "sphinx-autodoc2>=0.5.0",
    "myst-parser>=3.0.1",
    "docutils>=0.17",
]

[tool.hatch.version]
path = "src/extended_data_types/__init__.py"

[tool.hatch.envs.default]
type = "virtual"
path = ".venv"

[tool.pytest.ini_options]
addopts = ["-ra", "--strict-markers", "--strict-config"]
testpaths = "tests"
xfail_strict = true
filterwarnings = []

[tool.coverage.run]
branch = true
parallel = true
source = ["extended_data_types"]

[tool.coverage.paths]
source = ["src", ".tox/py*/**/site-packages"]

[tool.coverage.report]
show_missing = true
skip_covered = true
exclude_lines = ["no cov", "if __name__ == .__main__.:", "if TYPE_CHECKING:"]

[tool.codespell]
skip = '*.js,*.css,*.inv,*.lock,*.toml,*.json,*.yml,*.yaml'
count = true

[tool.interrogate]
omit-covered-files = true
verbose = 2
fail-under = 100
whitelist-regex = ["test_.*"]

[tool.black]
line-length = 88

[tool.ruff]
src = ["extended_data_types", "tests"]
exclude = ["docs"]

[tool.ruff.lint]
select = ["ALL"]
ignore = [
    "ANN", # Type annotations checks are better handled by Mypy, which provides more comprehensive type analysis and type-checking capabilities.
    "C901", # Ignore overly complex functions: Occasionally, complex code is necessary for performance optimization or to handle intricate logic that can't be easily simplified without sacrificing efficiency or clarity.
    "COM", # Black automatically handles commas in formatting, ensuring consistent style without the need for additional comma-specific linting.
    "D205", # One blank line required between the summary line and description: Inconsistent enforcement often leads to style churn and unnecessary changes in documentation-heavy code.
    "D415", # First line should end with a period, question mark, or exclamation point: This rule is overly strict and often doesn't impact the clarity or usefulness of docstrings.
    "DTZ007", # Naive datetime usage without timezone information is sometimes intentional, especially when working with legacy code or when timezone awareness is not required.
    "E501", # Line length is managed by Black, which reflows lines according to its style guide, maintaining readability without enforcing arbitrary line length limits.
    "EM102", # Using f-string without variable assignments: F-strings are often used for quick formatting even when not assigning values, especially in logging or print statements.
    "FBT", # Allow boolean arguments in function signatures; they provide simple, clear control over behavior.
    "FIX", # FIXME markers are useful for highlighting areas needing further attention or future fixes, and ignoring this rule allows these markers to remain as intentional reminders.
    "PLR0911", # Too many return statements: Functions with multiple exit points can improve code readability and maintainability by avoiding deeply nested logic.
    "PLR0913", # Too many arguments in function definition: Sometimes, functions require many parameters to handle complex configurations or provide flexibility, particularly in factory functions or when adhering to specific interface contracts.
    "RET505", # Unnecessary `elif` after `return`: Often used for clarity in maintaining separate conditional branches, enhancing readability despite technically being redundant.
    "TCH", # TYPE_CHECKING blocks: These are essential for type hinting without importing unnecessary dependencies at runtime, especially useful for preventing circular imports and keeping runtime environments lean, though they may affect automatic documentation generation.
    "TD", # TODO comments are a common part of development workflows for tracking pending tasks, and there’s often no need to enforce a specific style or behavior for these comments.
    "TID252", # Relative imports are perfectly acceptable within well-structured modules and packages, especially when maintaining a clear and logical project layout.
    "TRY003", # Simple strings are acceptable in exceptions without specifying type: Providing explicit exception messages improves readability and understanding, even when not adding extra error details.
    "TRY300", # Allow broad exception catches in certain contexts where specific handling of multiple exceptions is complex or unnecessary.
]

[tool.ruff.lint.per-file-ignores]
"tests/*" = [
    "B018", # In tests, expressions that seem "useless" can often serve as assertions or necessary side effects, making them valuable.
    "BLE", # Tests often intentionally handle exceptions differently, allowing for exploratory testing of failure cases and behavior under error conditions.
    "EM", # Exception handling in tests frequently diverges from typical patterns to deliberately provoke or verify specific failure paths.
    "LOG001", # Instantiating log messages directly in tests can help verify logging behavior and content, ensuring the logging system works as expected.
    "PLC1901", # Empty strings as test values may be intentional to specifically validate how empty or falsy data is handled by the system.
    "RUF012", # Type hints in tests can be more distracting than helpful, as test code is often more flexible and subject to change than production code.
    "S", # Security rules around input validation, like potential vulnerabilities, can be less critical in the controlled context of test code.
    "SIM300", # "Yoda conditions" (using literal comparisons like `if "value" == var:`) can sometimes make tests more readable, clarifying the expected values.
    "TRY", # The handling of exceptions in tests often needs to be more permissive and less structured to accommodate the exploration of edge cases and failure modes.
]

# Specific ignore rules for tests/__init__.py
"tests/__init__.py" = [
    "D100", # Missing docstring in public module
    "D104", # Missing docstring in public package
    "D103", # Missing docstring in public function
]

[tool.ruff.lint.pydocstyle]
convention = "google"
[tool.ruff.lint.isort]
lines-between-types = 1
lines-after-imports = 2

[tool.mypy]
strict = true
pretty = true
show_error_codes = true
enable_error_code = ["ignore-without-code"]
ignore_missing_imports = true
warn_return_any = false

[[tool.mypy.overrides]]
module = "tests.*"
ignore_errors = true

[[tool.mypy.overrides]]
module = "wrapt.*"
ignore_missing_imports = true

[tool.commitizen]
name = "cz_conventional_commits"
version = "3.0.1"
version_files = [
    "src/extended_data_types/__init__.py:__version__",
    "docs/conf.py:version",
]
tag_format = "$version"
annotated_tag = true
update_changelog_on_bump = true
bump_message = "New release: $current_version → $new_version [skip actions]"
template = "docs/templates/CHANGELOG.md.j2"
