.matrix-wheel-linux:
  image: ${IMAGE_REGISTRY}:${MANYLINUX}_${ARCH}_v2.0.0
  tags:
    - linux
    - docker
    - $RUNNER_TAG
  variables:
    IMAGE_REGISTRY: registry.gitlab.com/tango-controls/docker/pytango-builder
    MANYLINUX: manylinux2014
    GLIBC_TAG: '2_17' # depends on manylinux
    PYTHON_TAG: 'cp${PYTHON_VER}-cp${PYTHON_VER}${ABI_SUFFIX}'
    WHEEL_GLOB_PATTERN: pytango-*${PYTHON_TAG}*${ARCH}.whl
  parallel:
    matrix:
      - RUNNER_TAG: amd64
        ARCH: [x86_64, i686]
        PYTHON_VER: [39, 310, 311, 312]
      - RUNNER_TAG: aarch64
        ARCH: aarch64
        PYTHON_VER: [39, 310, 311, 312]

linux:build-wheel:
  extends: [.matrix-wheel-linux, .build-wheel]
  variables:
    GIT_SUBMODULE_STRATEGY: recursive
    CMAKE_ARGS: "--preset=ci-Linux-quiet"
  script:
    # build wheel
    - export BOOST_PYTHON_SUFFIX=$(/opt/python/${PYTHON_TAG}/bin/python -c "import sys;print(f'{sys.version_info[0]}{sys.version_info[1]}')")
    - |
      /opt/python/${PYTHON_TAG}/bin/python -m pip install build
      /opt/python/${PYTHON_TAG}/bin/python -m build --wheel --config-setting=cmake.build-type="RelWithDebInfo"
    # repair wheel, keeping any debug symbols (output will be in the 'wheelhouse' directory)
    - auditwheel repair dist/${WHEEL_GLOB_PATTERN}
    # rename file so it starts with 'pytango_dbg' instead of just 'pytango'
    - export WHEEL_FILE=$( basename $( ls wheelhouse/${WHEEL_GLOB_PATTERN} | head -n 1 ) )
    - export WHEEL_FILE_WITH_DEBUG_INFO="${WHEEL_FILE/pytango/pytango_dbg}"
    - mv wheelhouse/${WHEEL_FILE} wheelhouse/${WHEEL_FILE_WITH_DEBUG_INFO}
    # repair wheel, but this time strip all debug symbols, and keep the standard name
    - auditwheel repair --strip dist/${WHEEL_GLOB_PATTERN}
    # delete unrepaired wheel
    - rm -rf dist/*.whl
    # move repaired wheels to dist
    - mv wheelhouse/*.whl dist/

linux:build-sdist:
  stage: build
  variables:
    GIT_SUBMODULE_STRATEGY: recursive
  image: quay.io/condaforge/miniforge3:latest
  tags:
    - linux
    - docker
    - amd64
  before_script:
    - pip install twine build
  script:
    - python -m build --sdist
    - twine check dist/*
  artifacts:
    expire_in: 1 day
    paths:
      - dist/

linux:test-source:
  stage: test
  image: registry.gitlab.com/tango-controls/docker/micromamba:latest
  tags:
    - linux
    - docker
    - amd64
  variables:
    GIT_SUBMODULE_STRATEGY: recursive
    CMAKE_ARGS: "--preset=ci-Linux"
  # Avoid job to wait on wheels building
  needs: [linux:build-sdist]
  before_script:
    - ulimit -c unlimited
    - eval "$(/bin/micromamba shell hook -s bash)"
    # Install build and test dependencies
    - >
      micromamba install -y -n base -c conda-forge
      boost cppzmq cxx-compiler pkg-config
      python=$PYTHON_VERSION numpy git make
      packaging psutil pytest pytest-forked pytest-cov pystack gevent
      opentelemetry-api opentelemetry-sdk opentelemetry-exporter-otlp-proto-grpc opentelemetry-exporter-otlp-proto-http
      cmake clang-format clang-tools cppcheck ninja
    - micromamba activate base
    - |
      {
        if [[ $CPP_TANGO_VERSION == *"dev"* ]]; then
          micromamba install -c conda-forge -c tango-controls/label/dev cpptango-dbg=$CPP_TANGO_VERSION tango-test=${TANGO_TEST_VERSION}
        else
          micromamba install -c conda-forge -c conda-forge/label/cpptango_rc cpptango=$CPP_TANGO_VERSION tango-test=${TANGO_TEST_VERSION}
        fi
      } || {
        echo "Cannot find matching TangoTest, trying to building TangoTest against dev cpp_tango"
        if [[ $CPP_TANGO_VERSION == *"dev"* ]]; then
          micromamba install -c conda-forge -c tango-controls/label/dev cpptango-dbg=$CPP_TANGO_VERSION
        else
          micromamba install -c conda-forge -c conda-forge/label/cpptango_rc cpptango=$CPP_TANGO_VERSION
        fi
        pushd /tmp
        git clone --recurse-submodules https://gitlab.com/tango-controls/TangoTest.git
        cd TangoTest
        cmake --install-prefix="$CONDA_PREFIX" -B build
        make -C build install
        popd
      }
    # Install pytango
    - python -m pip install -v -e ".[tests,telemetry]"
  script:
    # run full test suite with telemetry disabled (default), then re-run telemetry-specific tests with it enabled
    - >
      pytest --cov --cov-branch --cov-report=term --run_extra_src_tests --junitxml=report.xml ||
      pytest --lf --cov --cov-branch --cov-report=term --cov-append --run_extra_src_tests --junitxml=report-lf.xml
    - >
      TANGO_TELEMETRY_ENABLE=on pytest -k telemetry
      --cov --cov-branch --cov-report=term --cov-report=html --cov-report=xml --cov-append --junitxml=report-telem.xml
    # check typing stubs
    - python cmake/check_stubs.py
  after_script:
    # Core files configuration
    - python_executable=$(which python)
    - dline="================================================================================"
    - |
      pattern=$(cat /proc/sys/kernel/core_pattern)
      if [ "$pattern" == "core.%e.%p.%t" ]; then
        echo "Core pattern is correct: $pattern";
        for core_file in core.*; do
          if [ -f "$core_file" ]; then
            echo -e "$dline\nAnalyzing core file: $core_file\n$dline\n"
            pystack core $core_file $python_executable --native-all --locals
            echo -e "$dline\n"
          fi
        done
      else
        echo "Core pattern is incorrect(expected: core.%e.%p.%t): $pattern";
      fi
  parallel:
    matrix:
      - PYTHON_VERSION: ['3.9', '3.10', '3.11', '3.12']
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    when: always
    paths:
      - htmlcov/
      - coverage.xml
      - report*.xml
    reports:
      junit: report*.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

linux:test-source-against-develop-dependencies:
  stage: test
  when: manual
  image: registry.gitlab.com/tango-controls/docker/micromamba:latest
  tags:
    - linux
    - docker
    - amd64
  variables:
    GIT_SUBMODULE_STRATEGY: recursive
    CMAKE_ARGS: "--preset=ci-Linux"
    IDL_SOURCE: "main"
    CPPTANGO_SOURCE: "main"
    TANGOTEST_SOURCE: "main"
    PYTHON_VERSION: "3.12"
  # Avoid job to wait on wheels building
  needs: [linux:build-sdist]
  before_script:
    - ulimit -c unlimited
    - eval "$(/bin/micromamba shell hook -s bash)"
    # Install build and test dependencies
    - >
      micromamba install -y -n base -c conda-forge
      boost cmake cppzmq cxx-compiler omniorb libtool pkg-config gnuconfig autoconf zeromq jpeg
      cpp-opentelemetry-api cpp-opentelemetry-sdk
      git make ninja python numpy packaging psutil pytest pytest-forked pytest-cov pystack gevent valgrind
      clang-format clang-tools cppcheck python=$PYTHON_VERSION
      opentelemetry-api opentelemetry-sdk opentelemetry-exporter-otlp-proto-grpc opentelemetry-exporter-otlp-proto-http
    - micromamba activate base
    # check which idl should we use and install it
    - |
      if [[ $IDL_SOURCE == "conda" ]]; then
        echo "Installing idl from conda-forge"
        micromamba install -c conda-forge tango-idl
      else
          echo "Building and installing idl from ${IDL_SOURCE} branch"
          pushd /tmp
          git clone --recurse-submodules --depth 1 -b $IDL_SOURCE https://gitlab.com/tango-controls/tango-idl
          cd tango-idl
          cmake --install-prefix="$CONDA_PREFIX" -B build
          make -C build install
          popd
      fi
    # check which cpptango should we use and install it
    - |
      if [[ $CPPTANGO_SOURCE = "conda" ]] ; then
        echo "Installing cpptango from conda-forge"
        micromamba install  -c conda-forge -c tango-controls/label/dev -c conda-forge/label/cpptango_rc cpptango-dbg=$CPP_TANGO_VERSION
      else
        echo "Building and installing cpptango from ${CPPTANGO_SOURCE} branch"
        pushd /tmp
        git clone --recurse-submodules --depth 1 -b $CPPTANGO_SOURCE https://gitlab.com/tango-controls/cppTango
        cd cppTango
        mkdir build
        cd build
        cmake ${CMAKE_ARGS} -DCMAKE_BUILD_TYPE=Debug -DCMAKE_VERBOSE_MAKEFILE=ON -DCMAKE_INSTALL_PREFIX="$CONDA_PREFIX" -DCMAKE_PREFIX_PATH="$CONDA_PREFIX" -DBUILD_TESTING=OFF -DCMAKE_CXX_STANDARD=17 -DTANGO_USE_TELEMETRY=ON ..
        make
        make install
        popd
      fi
    # check which tango test should we use and install it
    - |
      if [[ $TANGOTEST_SOURCE = "conda" ]] && [[$CPP_TANGO_VERSION != *"dev"*]]; then
        echo "Installing tangotest from conda-forge"
        micromamba install  -c conda-forge -c conda-forge/label/tango-test_rc tango-test=${TANGO_TEST_VERSION}
      else
        pushd /tmp
        if [[ $CPP_TANGO_VERSION == *"dev"* ]]; then
          echo "Building TangoTest head against dev cpp_tango"
          git clone --recurse-submodules https://gitlab.com/tango-controls/TangoTest.git
        else
          echo "Building and installing TangoTest from ${TANGOTEST_SOURCE}"
          git clone --recurse-submodules -b $TANGOTEST_SOURCE https://gitlab.com/tango-controls/TangoTest.git
        fi
        cd TangoTest
        cmake --install-prefix="$CONDA_PREFIX" -B build
        make -C build install
        popd
      fi
    # Install pytango
    - python -m pip install -v -e ".[tests,telemetry]"
  script:
    # run full test suite with telemetry disabled (default), then re-run telemetry-specific tests with it enabled
    - pytest || pytest --lf
    - TANGO_TELEMETRY_ENABLE=on pytest -k telemetry
    # now remove opentelemetry packages (all depend on opentelemetry-api), and see if some tests still pass
    - micromamba remove -y opentelemetry-api
    - TANGO_TELEMETRY_ENABLE=on pytest -k telemetry
    # check for valgrind issues
    - pushd tests/valgrind
    - ./run_valgrind_checks.sh
    - popd
  after_script:
    # Core files configuration
    - python_executable=$(which python)
    - dline="================================================================================"
    - |
      pattern=$(cat /proc/sys/kernel/core_pattern)
      if [ "$pattern" == "core.%e.%p.%t" ]; then
        echo "Core pattern is correct: $pattern";
        for core_file in core.*; do
          if [ -f "$core_file" ]; then
            echo -e "$dline\nAnalyzing core file: $core_file\n$dline\n"
            pystack core $core_file $python_executable --native-all --locals
            echo -e "$dline\n"
          fi
        done
      else
        echo "Core pattern is incorrect(expected: core.%e.%p.%t): $pattern";
      fi
  artifacts:
    when: always
    paths:
      - tests/valgrind/*.xml

linux:test-main-cpptango:
  stage: test
  image: registry.gitlab.com/tango-controls/docker/micromamba:latest
  tags:
    - linux
    - docker
    - amd64
  # Avoid job to wait on wheels building
  needs: [linux:build-sdist]
  before_script:
    - eval "$(/bin/micromamba shell hook -s bash)"
    # Install build and test dependencies
    - >
      micromamba install -y -n base -c tango-controls/label/dev -c conda-forge
      cpptango boost cmake cppzmq cxx-compiler git make pkg-config ninja
      python numpy
      packaging psutil pytest pytest-forked gevent valgrind
      opentelemetry-api opentelemetry-sdk opentelemetry-exporter-otlp-proto-grpc opentelemetry-exporter-otlp-proto-http
    - micromamba activate base
    # build and install TangoTest
    - pushd /tmp
    - git clone --recurse-submodules https://gitlab.com/tango-controls/TangoTest.git
    - cd TangoTest
    - cmake --install-prefix="$CONDA_PREFIX" -B build
    - make -C build install
    - popd
    # Install pytango
    - python -m pip install -v $(ls dist/pytango*.tar.gz)[tests,telemetry]
  script:
    # run telemetry-specific tests with telemetry enabled, then full test suite with it disabled (default)
    - TANGO_TELEMETRY_ENABLE=on pytest -k telemetry
    - >
      pytest --junitxml=report.xml ||
      pytest --lf --junitxml=report-lf.xml
    # now remove opentelemetry packages (all depend on opentelemetry-api), and see if some tests still pass
    - micromamba remove -y opentelemetry-api
    - TANGO_TELEMETRY_ENABLE=on pytest -k telemetry
    # check for valgrind issues
    - pushd tests/valgrind
    - ./run_valgrind_checks.sh
    - popd
  artifacts:
    when: always
    paths:
      - report*.xml
      - tests/valgrind/*.xml
    reports:
      junit: report*.xml
  rules:
    # Disable detached pipeline on MR
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: never
    - if: $CI_PIPELINE_SOURCE == "schedule"
      allow_failure: false
    - if: $CI_COMMIT_BRANCH || $CI_COMMIT_TAG
      when: manual
      allow_failure: true

.linux-test-wheel:
  stage: test
  extends: .matrix-wheel-linux
  needs: [linux:build-wheel]
  before_script:
    - /opt/python/${PYTHON_TAG}/bin/python -m venv venv
    - source venv/bin/activate
    - pip install --upgrade pip
    - pip install --prefer-binary $(find dist/${WHEEL_GLOB_PATTERN})[tests,telemetry]
  script:
    # run telemetry-specific tests with telemetry enabled, then full test suite with it disabled (default)
    - TANGO_TELEMETRY_ENABLE=on pytest -k telemetry
    - pytest || pytest --lf
  rules:
    - if: $CI_COMMIT_TAG && $ARCH == "aarch64"
      allow_failure: true
    - !reference [.rules-wheel, rules]

# All linux wheels need to be built to trigger those jobs
linux:test-wheel:
  extends: .linux-test-wheel

# Only wait on linux wheel for x86_64 python 3.12
linux:test-wheel:x86_64:3.12:
  extends: .linux-test-wheel
  when: manual
  parallel:
    matrix:
      - RUNNER_TAG: amd64
        ARCH: x86_64
        PYTHON_VER: "312"
  needs:
    - job: linux:build-wheel
      parallel:
        matrix:
          - RUNNER_TAG: amd64
            ARCH: x86_64
            PYTHON_VER: "312"

# Only wait on linux wheel for aarch64 python 3.12
linux:test-wheel:aarch64:3.12:
  extends: .linux-test-wheel
  when: manual
  parallel:
    matrix:
      - RUNNER_TAG: aarch64
        ARCH: aarch64
        PYTHON_VER: "312"
  needs:
    - job: linux:build-wheel
      parallel:
        matrix:
          - RUNNER_TAG: aarch64
            ARCH: aarch64
            PYTHON_VER: "312"

linux:test-pixi:
  extends: .test-pixi
  image: ghcr.io/prefix-dev/pixi:latest
  tags:
    - linux
    - docker
    - amd64
  before_script:
    - apt-get update
    - apt-get install -y git
