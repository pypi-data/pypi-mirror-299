import asyncio
from typing import Dict, List
from collections.abc import Callable
from settings.settings import TASK_PATH
from navconfig.logging import logging
from asyncdb.exceptions import ProviderError
from ..exceptions import DataNotFound, ComponentError
from .abstract import DtComponent
from .DbClient import DbClient


class DataInput(DbClient, DtComponent):
    """
    DataInput.

    Getting data from a database using asyncDB.

    Overview

        Getting data from a database using asyncDB

        .. table:: Properties
        :widths: auto

    +-------------+----------+-----------+-------------------------------------------------------+
    | Name        | Required | Summary                                                           |
    +-------------+----------+-----------+-------------------------------------------------------+
    |  driver     |   Yes    | pg (asyncdb driver postgresql)                                    |
    +-------------+----------+-----------+-------------------------------------------------------+
    | credentials |   Yes    | Credentials of the DB to which I am going to connect              |
    +-------------+----------+-----------+-------------------------------------------------------+
    | datasource  |   Yes    | The name of a datasource in our datasources definition            |
    +-------------+----------+-----------+-------------------------------------------------------+
    | file        |   Yes    | Name of a file in the program/sql folder with the query to be     |
    |             |          | executed                                                          |
    +-------------+----------+-----------+-------------------------------------------------------+
    | return      |   Yes    | Returns a data dictionary with two results: A list of the         |
    |             |          | executed queries and the results of the executed queries          |
    +-------------+----------+-----------+-------------------------------------------------------+
    |IteratorBase |   Yes    | Executes the component following it, as many times as data is     |
    |             |          | generated by the iterator                                         |
    +-------------+----------+-----------+-------------------------------------------------------+

    Return the list of arbitrary days

    """

    _credentials: dict = {
        "host": str,
        "port": str,
        "user": str,
        "password": str,
        "database": str,
    }


    def __init__(
        self,
        loop: asyncio.AbstractEventLoop = None,
        job: Callable = None,
        stat: Callable = None,
        **kwargs,
    ):
        self.queries: List = []
        self.credentials: Dict = {}
        if "credentials" in kwargs:
            self.credentials = kwargs["credentials"]
            del kwargs["credentials"]
        try:
            self.driver = kwargs["driver"]
            del kwargs["driver"]
        except KeyError:
            if "driver" in self.credentials:
                self.driver = self.credentials["driver"]
                del self.credentials["driver"]
            else:
                self.driver = "pg"  # default driver
        DbClient.__init__(
            self, driver=self.driver, credentials=self.credentials, **kwargs
        )
        DtComponent.__init__(self, loop=loop, job=job, stat=stat, **kwargs)

    async def start(self, **kwargs) -> bool:
        await super(DataInput, self).start(**kwargs)

        self.processing_credentials()

        self.queries = []
        if hasattr(self, "query"):
            if isinstance(self.query, str):  # sigle query # pylint: disable=E0203
                self.query = self.mask_replacement(self.query)
                self.queries.append(self.query)
            elif isinstance(self.query, list):  # multiple queries:
                for query in self.query:
                    query = self.mask_replacement(query)
                    self.queries.append(query)
            elif isinstance(self.query, dict):  # named queries:
                for name, query in self.query.items():
                    qs = {}
                    query = self.mask_replacement(query)
                    qs[name] = query
                    self.queries.append(qs)
        elif hasattr(self, "file"):  # query from a File
            if isinstance(self.file, str):  # sigle query
                self._logger.debug(f"Execute SQL File: {self.file!s}")
                file_path = TASK_PATH.joinpath(self._program, "sql", self.file)
                qs = await self.open_sqlfile(file_path)
                self.queries.append(qs)
            elif isinstance(self.file, list):  # multiple queries:
                for file in self.file:
                    query = await self.open_sqlfile(file)
                    self.queries.append(qs)
        return True

    async def run(self):
        try:
            db = await self.connection(
                driver=self.driver, credentials=self.credentials, event_loop=self._loop
            )
        except Exception as e:
            logging.error(e)
            raise
        try:
            async with await db.connection() as conn:
                if conn.is_connected() is not True:
                    raise ComponentError(
                        f"DB Error: driver {self.driver} is not connected."
                    )
                results = []
                for query in self.queries:
                    if isinstance(query, str):
                        result = await self._query(query, conn)
                        rst = len(result)
                        st = {"query": query, "result": rst}
                        self.add_metric(f"Query: {query}", st)
                        if self.as_dataframe is True:
                            # converting to a dataframe
                            df = await self.get_dataframe(result)
                            results.append(df)
                        else:
                            results.append(result)
                    elif isinstance(query, dict):
                        qs = {}
                        [(key, value)] = query.items()
                        result = await self._query(value, conn)
                        rst = len(result)
                        st = {"query": query, "result": rst}
                        self.add_metric(f"Query: {key}", st)
                        if self.as_dataframe is True:
                            df = await self.get_dataframe(result)
                            qs[key] = df
                        else:
                            qs[key] = result
                        results.append(qs)
                if len(results) == 1:
                    self._result = results[0]
                else:
                    self._result = results
                return self._result
        except DataNotFound:
            raise
        except ProviderError as e:
            raise ComponentError(f"Error connecting to database: {e}") from e
        except Exception as e:
            logging.error(e)
            raise

    def processing_credentials(self):
        if self.credentials:
            for value, dtype in self._credentials.items():
                try:
                    if type(self.credentials[value]) == dtype:
                        default = getattr(self, value, self.credentials[value])
                        val = self.get_env_value(
                            self.credentials[value], default=default
                        )
                        self.credentials[value] = val
                except (TypeError, KeyError) as ex:
                    self._logger.error(f"{__name__}: Wrong or missing Credentials")
                    raise ComponentError(
                        f"{__name__}: Wrong or missing Credentials"
                    ) from ex
