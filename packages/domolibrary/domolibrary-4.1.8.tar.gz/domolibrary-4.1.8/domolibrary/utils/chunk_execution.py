# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/chunk_execution.ipynb.

# %% auto 0
__all__ = ['auto_retry_async', 'gather_with_concurrency', 'run_sequence', 'chunk_list']

# %% ../../nbs/utils/chunk_execution.ipynb 2
from typing import Any, Awaitable,Callable, List
import asyncio
import functools

# %% ../../nbs/utils/chunk_execution.ipynb 3
def auto_retry_async(max_retry = 1, exceptions_to_ignore : List[Exception] = None , sleep_beween_retry = 5): 
    exceptions_to_ignore = exceptions_to_ignore or []

    def actual_decorator(func: Callable):
        @functools.wraps(func)
        async def wrapper( *args, **kwargs ) :

            retry = 0 
            
            while retry <= max_retry:
                try:
                    return await func( *args, **kwargs)
                
                    
                except Exception as e:
                    if any((isinstance(e, ig_ex) for ig_ex in exceptions_to_ignore)):
                        raise e

                    if (retry >= max_retry) :
                        raise e
                    
                    retry +=1

                    print(f"retry decorator attempt - {retry}, {e}")
                    await asyncio.sleep(sleep_beween_retry)
            
        return wrapper
    return actual_decorator

# %% ../../nbs/utils/chunk_execution.ipynb 6
async def gather_with_concurrency(
    *coros,  # list of coroutines to await
    n=60,  # number of open coroutines
):
    """limits the number of open coroutines at a time."""

    semaphore = asyncio.Semaphore(n)

    async def sem_coro(coro):
        async with semaphore:
            return await coro

    return await asyncio.gather(*(sem_coro(c) for c in coros))

# %% ../../nbs/utils/chunk_execution.ipynb 9
async def run_sequence(
    *functions: Awaitable[Any],  # comma separated list of functions
) -> None:  # no explicit return
    """executes a sequence of functions"""

    return [await function for function in functions]

# %% ../../nbs/utils/chunk_execution.ipynb 12
def chunk_list(
    obj_ls: list[any],  # list of entities to split into n chunks
    chunk_size: int,  # entities per sub list
) -> list[list[dict]]:  # returns a list of chunk_size lists of objects

    return [
        obj_ls[i * chunk_size : (i + 1) * chunk_size]
        for i in range((len(obj_ls) + chunk_size - 1) // chunk_size)
    ]
