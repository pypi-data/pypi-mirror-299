"use strict";
(self["webpackChunk_jupyrdf_jupyter_elk"] = self["webpackChunk_jupyrdf_jupyter_elk"] || []).push([["vendors-node_modules_sprotty-protocol_lib_actions_js-node_modules_sprotty-protocol_lib_utils_-67982b"],{

/***/ "./node_modules/sprotty-protocol/lib/actions.js":
/*!******************************************************!*\
  !*** ./node_modules/sprotty-protocol/lib/actions.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/********************************************************************************
 * Copyright (c) 2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReconnectAction = exports.ApplyLabelEditAction = exports.DeleteElementAction = exports.CreateElementAction = exports.ExportSvgAction = exports.RequestExportSvgAction = exports.HoverFeedbackAction = exports.MoveAction = exports.RedoAction = exports.UndoAction = exports.BringToFrontAction = exports.ViewportResult = exports.GetViewportAction = exports.SetViewportAction = exports.FitToScreenAction = exports.CenterAction = exports.LayoutAction = exports.OpenAction = exports.CollapseExpandAllAction = exports.CollapseExpandAction = exports.SelectionResult = exports.GetSelectionAction = exports.SelectAllAction = exports.SelectAction = exports.LoggingAction = exports.ComputedBoundsAction = exports.RequestBoundsAction = exports.SetBoundsAction = exports.SetPopupModelAction = exports.RequestPopupModelAction = exports.UpdateModelAction = exports.SetModelAction = exports.RequestModelAction = exports.RejectAction = exports.isResponseAction = exports.setRequestContext = exports.generateRequestId = exports.isRequestAction = exports.isAction = exports.isActionMessage = void 0;
const object_1 = __webpack_require__(/*! ./utils/object */ "./node_modules/sprotty-protocol/lib/utils/object.js");
function isActionMessage(object) {
    return (0, object_1.hasOwnProperty)(object, 'action');
}
exports.isActionMessage = isActionMessage;
function isAction(object) {
    return (0, object_1.hasOwnProperty)(object, 'kind', 'string');
}
exports.isAction = isAction;
function isRequestAction(object) {
    return (0, object_1.hasOwnProperty)(object, 'requestId', 'string');
}
exports.isRequestAction = isRequestAction;
let requestContext = '';
let nextRequestId = 1;
/**
 * Generate a unique `requestId` for a request action.
 */
function generateRequestId() {
    return `${requestContext}_${nextRequestId++}`;
}
exports.generateRequestId = generateRequestId;
/**
 * Configure the context in which request actions are created. This is typically either
 * 'client' or 'server' to avoid collisions of request IDs.
 */
function setRequestContext(context) {
    requestContext = context;
}
exports.setRequestContext = setRequestContext;
/**
 * A response action is sent to respond to a request action. The `responseId` must match
 * the `requestId` of the preceding request. In case the `responseId` is empty or undefined,
 * the action is handled as standalone, i.e. it was fired without a preceding request.
 */
function isResponseAction(object) {
    return (0, object_1.hasOwnProperty)(object, 'responseId', 'string') && object.responseId !== '';
}
exports.isResponseAction = isResponseAction;
var RejectAction;
(function (RejectAction) {
    RejectAction.KIND = 'rejectRequest';
    function create(options) {
        return {
            kind: RejectAction.KIND,
            message: options.message,
            detail: options.detail,
            responseId: options.requestId
        };
    }
    RejectAction.create = create;
})(RejectAction || (exports.RejectAction = RejectAction = {}));
var RequestModelAction;
(function (RequestModelAction) {
    RequestModelAction.KIND = 'requestModel';
    function create(options) {
        return {
            kind: RequestModelAction.KIND,
            options,
            requestId: generateRequestId()
        };
    }
    RequestModelAction.create = create;
})(RequestModelAction || (exports.RequestModelAction = RequestModelAction = {}));
var SetModelAction;
(function (SetModelAction) {
    SetModelAction.KIND = 'setModel';
    function create(newRoot, requestId = '') {
        return {
            kind: SetModelAction.KIND,
            newRoot,
            responseId: requestId
        };
    }
    SetModelAction.create = create;
})(SetModelAction || (exports.SetModelAction = SetModelAction = {}));
var UpdateModelAction;
(function (UpdateModelAction) {
    UpdateModelAction.KIND = 'updateModel';
    function create(input, options = {}) {
        if (Array.isArray(input)) {
            return {
                kind: UpdateModelAction.KIND,
                matches: input,
                animate: options.animate,
                cause: options.cause
            };
        }
        else {
            return {
                kind: UpdateModelAction.KIND,
                newRoot: input,
                animate: options.animate,
                cause: options.cause
            };
        }
    }
    UpdateModelAction.create = create;
})(UpdateModelAction || (exports.UpdateModelAction = UpdateModelAction = {}));
var RequestPopupModelAction;
(function (RequestPopupModelAction) {
    RequestPopupModelAction.KIND = 'requestPopupModel';
    function create(options) {
        return {
            kind: RequestPopupModelAction.KIND,
            elementId: options.elementId,
            bounds: options.bounds,
            requestId: generateRequestId()
        };
    }
    RequestPopupModelAction.create = create;
})(RequestPopupModelAction || (exports.RequestPopupModelAction = RequestPopupModelAction = {}));
var SetPopupModelAction;
(function (SetPopupModelAction) {
    SetPopupModelAction.KIND = 'setPopupModel';
    function create(newRoot, requestId = '') {
        return {
            kind: SetPopupModelAction.KIND,
            newRoot,
            responseId: requestId
        };
    }
    SetPopupModelAction.create = create;
})(SetPopupModelAction || (exports.SetPopupModelAction = SetPopupModelAction = {}));
var SetBoundsAction;
(function (SetBoundsAction) {
    SetBoundsAction.KIND = 'setBounds';
    function create(bounds) {
        return {
            kind: SetBoundsAction.KIND,
            bounds
        };
    }
    SetBoundsAction.create = create;
})(SetBoundsAction || (exports.SetBoundsAction = SetBoundsAction = {}));
var RequestBoundsAction;
(function (RequestBoundsAction) {
    RequestBoundsAction.KIND = 'requestBounds';
    function create(newRoot) {
        return {
            kind: RequestBoundsAction.KIND,
            newRoot,
            requestId: generateRequestId()
        };
    }
    RequestBoundsAction.create = create;
})(RequestBoundsAction || (exports.RequestBoundsAction = RequestBoundsAction = {}));
var ComputedBoundsAction;
(function (ComputedBoundsAction) {
    ComputedBoundsAction.KIND = 'computedBounds';
    function create(bounds, options = {}) {
        var _a;
        return {
            kind: ComputedBoundsAction.KIND,
            bounds,
            revision: options.revision,
            alignments: options.alignments,
            responseId: (_a = options.requestId) !== null && _a !== void 0 ? _a : ''
        };
    }
    ComputedBoundsAction.create = create;
})(ComputedBoundsAction || (exports.ComputedBoundsAction = ComputedBoundsAction = {}));
var LoggingAction;
(function (LoggingAction) {
    LoggingAction.KIND = 'logging';
    function create(options) {
        return Object.assign({ kind: LoggingAction.KIND }, options);
    }
    LoggingAction.create = create;
})(LoggingAction || (exports.LoggingAction = LoggingAction = {}));
var SelectAction;
(function (SelectAction) {
    SelectAction.KIND = 'elementSelected';
    function create(options) {
        var _a, _b;
        return {
            kind: SelectAction.KIND,
            selectedElementsIDs: (_a = options.selectedElementsIDs) !== null && _a !== void 0 ? _a : [],
            deselectedElementsIDs: (_b = options.deselectedElementsIDs) !== null && _b !== void 0 ? _b : []
        };
    }
    SelectAction.create = create;
})(SelectAction || (exports.SelectAction = SelectAction = {}));
var SelectAllAction;
(function (SelectAllAction) {
    SelectAllAction.KIND = 'allSelected';
    function create(options = {}) {
        var _a;
        return {
            kind: SelectAllAction.KIND,
            select: (_a = options.select) !== null && _a !== void 0 ? _a : true
        };
    }
    SelectAllAction.create = create;
})(SelectAllAction || (exports.SelectAllAction = SelectAllAction = {}));
var GetSelectionAction;
(function (GetSelectionAction) {
    GetSelectionAction.KIND = 'getSelection';
    function create() {
        return {
            kind: GetSelectionAction.KIND,
            requestId: generateRequestId()
        };
    }
    GetSelectionAction.create = create;
})(GetSelectionAction || (exports.GetSelectionAction = GetSelectionAction = {}));
var SelectionResult;
(function (SelectionResult) {
    SelectionResult.KIND = 'selectionResult';
    function create(selectedElementsIDs, requestId) {
        return {
            kind: SelectionResult.KIND,
            selectedElementsIDs,
            responseId: requestId
        };
    }
    SelectionResult.create = create;
})(SelectionResult || (exports.SelectionResult = SelectionResult = {}));
var CollapseExpandAction;
(function (CollapseExpandAction) {
    CollapseExpandAction.KIND = 'collapseExpand';
    function create(options) {
        var _a, _b;
        return {
            kind: CollapseExpandAction.KIND,
            expandIds: (_a = options.expandIds) !== null && _a !== void 0 ? _a : [],
            collapseIds: (_b = options.collapseIds) !== null && _b !== void 0 ? _b : []
        };
    }
    CollapseExpandAction.create = create;
})(CollapseExpandAction || (exports.CollapseExpandAction = CollapseExpandAction = {}));
var CollapseExpandAllAction;
(function (CollapseExpandAllAction) {
    CollapseExpandAllAction.KIND = 'collapseExpandAll';
    function create(options = {}) {
        var _a;
        return {
            kind: CollapseExpandAllAction.KIND,
            expand: (_a = options.expand) !== null && _a !== void 0 ? _a : true
        };
    }
    CollapseExpandAllAction.create = create;
})(CollapseExpandAllAction || (exports.CollapseExpandAllAction = CollapseExpandAllAction = {}));
var OpenAction;
(function (OpenAction) {
    OpenAction.KIND = 'open';
    function create(elementId) {
        return {
            kind: OpenAction.KIND,
            elementId
        };
    }
    OpenAction.create = create;
})(OpenAction || (exports.OpenAction = OpenAction = {}));
var LayoutAction;
(function (LayoutAction) {
    LayoutAction.KIND = 'layout';
    function create(options = {}) {
        return {
            kind: LayoutAction.KIND,
            layoutType: options.layoutType,
            elementIds: options.elementIds
        };
    }
    LayoutAction.create = create;
})(LayoutAction || (exports.LayoutAction = LayoutAction = {}));
var CenterAction;
(function (CenterAction) {
    CenterAction.KIND = 'center';
    function create(elementIds, options = {}) {
        var _a, _b;
        return {
            kind: CenterAction.KIND,
            elementIds,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
            retainZoom: (_b = options.retainZoom) !== null && _b !== void 0 ? _b : false,
            zoomScale: options.zoomScale
        };
    }
    CenterAction.create = create;
})(CenterAction || (exports.CenterAction = CenterAction = {}));
var FitToScreenAction;
(function (FitToScreenAction) {
    FitToScreenAction.KIND = 'fit';
    function create(elementIds, options = {}) {
        var _a;
        return {
            kind: FitToScreenAction.KIND,
            elementIds,
            padding: options.padding,
            maxZoom: options.maxZoom,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
        };
    }
    FitToScreenAction.create = create;
})(FitToScreenAction || (exports.FitToScreenAction = FitToScreenAction = {}));
var SetViewportAction;
(function (SetViewportAction) {
    SetViewportAction.KIND = 'viewport';
    function create(elementId, newViewport, options = {}) {
        var _a;
        return {
            kind: SetViewportAction.KIND,
            elementId,
            newViewport,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
        };
    }
    SetViewportAction.create = create;
})(SetViewportAction || (exports.SetViewportAction = SetViewportAction = {}));
var GetViewportAction;
(function (GetViewportAction) {
    GetViewportAction.KIND = 'getViewport';
    function create() {
        return {
            kind: GetViewportAction.KIND,
            requestId: generateRequestId()
        };
    }
    GetViewportAction.create = create;
})(GetViewportAction || (exports.GetViewportAction = GetViewportAction = {}));
var ViewportResult;
(function (ViewportResult) {
    ViewportResult.KIND = 'viewportResult';
    function create(viewport, canvasBounds, requestId) {
        return {
            kind: ViewportResult.KIND,
            viewport,
            canvasBounds,
            responseId: requestId
        };
    }
    ViewportResult.create = create;
})(ViewportResult || (exports.ViewportResult = ViewportResult = {}));
var BringToFrontAction;
(function (BringToFrontAction) {
    BringToFrontAction.KIND = 'bringToFront';
    function create(elementIDs) {
        return {
            kind: BringToFrontAction.KIND,
            elementIDs
        };
    }
    BringToFrontAction.create = create;
})(BringToFrontAction || (exports.BringToFrontAction = BringToFrontAction = {}));
var UndoAction;
(function (UndoAction) {
    UndoAction.KIND = 'undo';
    function create() {
        return {
            kind: UndoAction.KIND
        };
    }
    UndoAction.create = create;
})(UndoAction || (exports.UndoAction = UndoAction = {}));
var RedoAction;
(function (RedoAction) {
    RedoAction.KIND = 'redo';
    function create() {
        return {
            kind: RedoAction.KIND
        };
    }
    RedoAction.create = create;
})(RedoAction || (exports.RedoAction = RedoAction = {}));
var MoveAction;
(function (MoveAction) {
    MoveAction.KIND = 'move';
    function create(moves, options = {}) {
        var _a, _b, _c;
        return {
            kind: MoveAction.KIND,
            moves,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
            finished: (_b = options.finished) !== null && _b !== void 0 ? _b : false,
            stoppable: (_c = options.stoppable) !== null && _c !== void 0 ? _c : false
        };
    }
    MoveAction.create = create;
})(MoveAction || (exports.MoveAction = MoveAction = {}));
var HoverFeedbackAction;
(function (HoverFeedbackAction) {
    HoverFeedbackAction.KIND = 'hoverFeedback';
    function create(options) {
        return {
            kind: HoverFeedbackAction.KIND,
            mouseoverElement: options.mouseoverElement,
            mouseIsOver: options.mouseIsOver
        };
    }
    HoverFeedbackAction.create = create;
})(HoverFeedbackAction || (exports.HoverFeedbackAction = HoverFeedbackAction = {}));
var RequestExportSvgAction;
(function (RequestExportSvgAction) {
    RequestExportSvgAction.KIND = 'requestExportSvg';
    function create(options) {
        return {
            kind: RequestExportSvgAction.KIND,
            requestId: generateRequestId(),
            options
        };
    }
    RequestExportSvgAction.create = create;
})(RequestExportSvgAction || (exports.RequestExportSvgAction = RequestExportSvgAction = {}));
var ExportSvgAction;
(function (ExportSvgAction) {
    ExportSvgAction.KIND = 'exportSvg';
    function create(svg, requestId, options) {
        return {
            kind: ExportSvgAction.KIND,
            svg,
            responseId: requestId,
            options
        };
    }
    ExportSvgAction.create = create;
})(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));
var CreateElementAction;
(function (CreateElementAction) {
    CreateElementAction.KIND = 'createElement';
    function create(elementSchema, options) {
        return {
            kind: CreateElementAction.KIND,
            elementSchema,
            containerId: options.containerId
        };
    }
    CreateElementAction.create = create;
})(CreateElementAction || (exports.CreateElementAction = CreateElementAction = {}));
var DeleteElementAction;
(function (DeleteElementAction) {
    DeleteElementAction.KIND = 'delete';
    function create(elementIds) {
        return {
            kind: DeleteElementAction.KIND,
            elementIds
        };
    }
    DeleteElementAction.create = create;
})(DeleteElementAction || (exports.DeleteElementAction = DeleteElementAction = {}));
var ApplyLabelEditAction;
(function (ApplyLabelEditAction) {
    ApplyLabelEditAction.KIND = 'applyLabelEdit';
    function create(labelId, text) {
        return {
            kind: ApplyLabelEditAction.KIND,
            labelId,
            text
        };
    }
    ApplyLabelEditAction.create = create;
})(ApplyLabelEditAction || (exports.ApplyLabelEditAction = ApplyLabelEditAction = {}));
var ReconnectAction;
(function (ReconnectAction) {
    ReconnectAction.KIND = 'reconnect';
    function create(options) {
        return {
            kind: ReconnectAction.KIND,
            routableId: options.routableId,
            newSourceId: options.newSourceId,
            newTargetId: options.newTargetId
        };
    }
    ReconnectAction.create = create;
})(ReconnectAction || (exports.ReconnectAction = ReconnectAction = {}));


/***/ }),

/***/ "./node_modules/sprotty-protocol/lib/utils/async.js":
/*!**********************************************************!*\
  !*** ./node_modules/sprotty-protocol/lib/utils/async.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {


/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deferred = void 0;
/**
 * Simple implementation of the deferred pattern.
 * An object that exposes a promise and functions to resolve and reject it.
 */
class Deferred {
    constructor() {
        this._state = 'unresolved';
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
        this.promise.then(res => this._state = 'resolved', rej => this._state = 'rejected');
    }
    set state(state) {
        if (this._state === 'unresolved') {
            this._state = state;
        }
    }
    get state() {
        return this._state;
    }
}
exports.Deferred = Deferred;


/***/ }),

/***/ "./node_modules/sprotty-protocol/lib/utils/geometry.js":
/*!*************************************************************!*\
  !*** ./node_modules/sprotty-protocol/lib/utils/geometry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.almostEquals = exports.toRadians = exports.toDegrees = exports.Bounds = exports.isBounds = exports.Dimension = exports.centerOfLine = exports.angleBetweenPoints = exports.angleOfPoint = exports.Point = void 0;
const object_1 = __webpack_require__(/*! ./object */ "./node_modules/sprotty-protocol/lib/utils/object.js");
var Point;
(function (Point) {
    /**
     * (x,y) coordinates of the origin.
     */
    Point.ORIGIN = Object.freeze({
        x: 0,
        y: 0
    });
    /**
     * Adds two points.
     * @param {Point} p1 - First point
     * @param {Point} p2 - Second point
     * @returns {Point} The sum of the two points
     */
    function add(p1, p2) {
        return {
            x: p1.x + p2.x,
            y: p1.y + p2.y
        };
    }
    Point.add = add;
    /**
     * Subtracts two points.
     * @param {Point} p1 - First point
     * @param {Point} p2 - Second point
     * @returns {Point} The difference of the two points
     */
    function subtract(p1, p2) {
        return {
            x: p1.x - p2.x,
            y: p1.y - p2.y
        };
    }
    Point.subtract = subtract;
    /**
     * Specifies whether a point has exactly the same coordinates as another point.
     * @param {Point} point1 a point
     * @param {Point} point2 another point
     * @returns {boolean} `true` if `point1` has exactly the same `x` and `y` values as `point2`, `false` otherwise.
     */
    function equals(point1, point2) {
        return point1.x === point2.x && point1.y === point2.y;
    }
    Point.equals = equals;
    /**
     * Computes a point that is the original `point` shifted towards `refPoint` by the given `distance`.
     * @param {Point} point - Point to shift
     * @param {Point} refPoint - Point to shift towards
     * @param {Point} distance - Distance to shift
     */
    function shiftTowards(point, refPoint, distance) {
        const diff = subtract(refPoint, point);
        const normalized = normalize(diff);
        const shift = { x: normalized.x * distance, y: normalized.y * distance };
        return add(point, shift);
    }
    Point.shiftTowards = shiftTowards;
    /**
     * Computes the normalized vector from the vector given in `point`; that is, computing its unit vector.
     * @param {Point} point - Point representing the vector to be normalized
     * @returns {Point} The normalized point
     */
    function normalize(point) {
        const mag = magnitude(point);
        if (mag === 0 || mag === 1) {
            return Point.ORIGIN;
        }
        return {
            x: point.x / mag,
            y: point.y / mag
        };
    }
    Point.normalize = normalize;
    /**
     * Computes the magnitude of the vector given in `point`.
     * @param {Point} point - Point representing the vector to compute the magnitude for
     * @returns {number} The magnitude or also known as length of the `point`
     */
    function magnitude(point) {
        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
    }
    Point.magnitude = magnitude;
    /**
     * Calculates a linear combination of p0 and p1 using lambda, i.e.
     *   (1-lambda) * p0 + lambda * p1
     */
    function linear(p0, p1, lambda) {
        return {
            x: (1 - lambda) * p0.x + lambda * p1.x,
            y: (1 - lambda) * p0.y + lambda * p1.y
        };
    }
    Point.linear = linear;
    /**
     * Returns the "straight line" distance between two points.
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The Eucledian distance
     */
    function euclideanDistance(a, b) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    Point.euclideanDistance = euclideanDistance;
    /**
     * Returns the distance between two points in a grid, using a
     * strictly vertical and/or horizontal path (versus straight line).
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The Manhattan distance
     */
    function manhattanDistance(a, b) {
        return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);
    }
    Point.manhattanDistance = manhattanDistance;
    /**
     * Returns the maximum of the horizontal and the vertical distance.
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The maximum distance
     */
    function maxDistance(a, b) {
        return Math.max(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
    }
    Point.maxDistance = maxDistance;
    /**
     * Returns the dot product of two points.
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The dot product
     */
    function dotProduct(a, b) {
        return a.x * b.x + a.y * b.y;
    }
    Point.dotProduct = dotProduct;
})(Point || (exports.Point = Point = {}));
/**
 * Computes the angle in radians of the given point to the x-axis of the coordinate system.
 * The result is in the range [-pi, pi].
 * @param {Point} p - A point in the Eucledian plane
 */
function angleOfPoint(p) {
    return Math.atan2(p.y, p.x);
}
exports.angleOfPoint = angleOfPoint;
/**
 * Computes the angle in radians between the two given points (relative to the origin of the coordinate system).
 * The result is in the range [0, pi]. Returns NaN if the points are equal.
 * @param {Point} a - First point
 * @param {Point} b - Second point
 */
function angleBetweenPoints(a, b) {
    const lengthProduct = Math.sqrt((a.x * a.x + a.y * a.y) * (b.x * b.x + b.y * b.y));
    if (isNaN(lengthProduct) || lengthProduct === 0)
        return NaN;
    const dotProduct = a.x * b.x + a.y * b.y;
    return Math.acos(dotProduct / lengthProduct);
}
exports.angleBetweenPoints = angleBetweenPoints;
/**
 * Computes the center of the line segment spanned by the two given points.
 * @param {Point} s - Start point of the line
 * @param {Point} e - End point of the line
 */
function centerOfLine(s, e) {
    const b = {
        x: s.x > e.x ? e.x : s.x,
        y: s.y > e.y ? e.y : s.y,
        width: Math.abs(e.x - s.x),
        height: Math.abs(e.y - s.y)
    };
    return Bounds.center(b);
}
exports.centerOfLine = centerOfLine;
var Dimension;
(function (Dimension) {
    /**
     * A dimension with both width and height set to a negative value, which is considered as undefined.
     */
    Dimension.EMPTY = Object.freeze({
        width: -1,
        height: -1
    });
    /**
     * Checks whether the given dimention is valid, i.e. the width and height are non-zero.
     * @param {Dimension} b - Dimension object
     * @returns {boolean} `true` if the dimension is valid
     */
    function isValid(d) {
        return d.width >= 0 && d.height >= 0;
    }
    Dimension.isValid = isValid;
})(Dimension || (exports.Dimension = Dimension = {}));
function isBounds(element) {
    return (0, object_1.hasOwnProperty)(element, ['x', 'y', 'width', 'height']);
}
exports.isBounds = isBounds;
var Bounds;
(function (Bounds) {
    Bounds.EMPTY = Object.freeze({
        x: 0,
        y: 0,
        width: -1,
        height: -1
    });
    /**
     * Combines the bounds of two objects into one, so that the new bounds
     * are the minimum bounds that covers both of the original bounds.
     * @param {Bounds} b0 - First bounds object
     * @param {Bounds} b1 - Second bounds object
     * @returns {Bounds} The combined bounds
     */
    function combine(b0, b1) {
        if (!Dimension.isValid(b0))
            return Dimension.isValid(b1) ? b1 : Bounds.EMPTY;
        if (!Dimension.isValid(b1))
            return b0;
        const minX = Math.min(b0.x, b1.x);
        const minY = Math.min(b0.y, b1.y);
        const maxX = Math.max(b0.x + (b0.width >= 0 ? b0.width : 0), b1.x + (b1.width >= 0 ? b1.width : 0));
        const maxY = Math.max(b0.y + (b0.height >= 0 ? b0.height : 0), b1.y + (b1.height >= 0 ? b1.height : 0));
        return {
            x: minX, y: minY, width: maxX - minX, height: maxY - minY
        };
    }
    Bounds.combine = combine;
    /**
     * Translates the given bounds.
     * @param {Bounds} b - Bounds object
     * @param {Point} p - Vector by which to translate the bounds
     * @returns {Bounds} The translated bounds
     */
    function translate(b, p) {
        return {
            x: b.x + p.x,
            y: b.y + p.y,
            width: b.width,
            height: b.height
        };
    }
    Bounds.translate = translate;
    /**
     * Returns the center point of the bounds of an object
     * @param {Bounds} b - Bounds object
     * @returns {Point} the center point
     */
    function center(b) {
        return {
            x: b.x + (b.width >= 0 ? 0.5 * b.width : 0),
            y: b.y + (b.height >= 0 ? 0.5 * b.height : 0)
        };
    }
    Bounds.center = center;
    /**
    * Checks whether the point p is included in the bounds b.
    */
    function includes(b, p) {
        return p.x >= b.x && p.x <= b.x + b.width && p.y >= b.y && p.y <= b.y + b.height;
    }
    Bounds.includes = includes;
})(Bounds || (exports.Bounds = Bounds = {}));
/**
 * Converts from radians to degrees
 * @param {number} a - A value in radians
 * @returns {number} The converted value
 */
function toDegrees(a) {
    return a * 180 / Math.PI;
}
exports.toDegrees = toDegrees;
/**
 * Converts from degrees to radians
 * @param {number} a - A value in degrees
 * @returns {number} The converted value
 */
function toRadians(a) {
    return a * Math.PI / 180;
}
exports.toRadians = toRadians;
/**
 * Returns whether two numbers are almost equal, within a small margin (0.001)
 * @param {number} a - First number
 * @param {number} b - Second number
 * @returns {boolean} True if the two numbers are almost equal
 */
function almostEquals(a, b) {
    return Math.abs(a - b) < 1e-3;
}
exports.almostEquals = almostEquals;


/***/ }),

/***/ "./node_modules/sprotty-protocol/lib/utils/model-utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/sprotty-protocol/lib/utils/model-utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


/********************************************************************************
 * Copyright (c) 2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SModelIndex = exports.findElement = exports.getSubType = exports.getBasicType = exports.applyBounds = exports.cloneModel = void 0;
/**
 * Clone a given model. This function requires that the model is serializable, so it's
 * free of cycles and functions.
 */
function cloneModel(model) {
    return JSON.parse(JSON.stringify(model));
}
exports.cloneModel = cloneModel;
/**
 * Apply the computed bounds to the given model. This ensures that the model has complete
 * information about positions and sizes derived from its actual rendering in the frontend.
 */
function applyBounds(root, action) {
    const index = new SModelIndex();
    index.add(root);
    for (const b of action.bounds) {
        const element = index.getById(b.elementId);
        if (element) {
            const bae = element;
            if (b.newPosition) {
                bae.position = { x: b.newPosition.x, y: b.newPosition.y };
            }
            if (b.newSize) {
                bae.size = { width: b.newSize.width, height: b.newSize.height };
            }
        }
    }
    if (action.alignments) {
        for (const a of action.alignments) {
            const element = index.getById(a.elementId);
            if (element) {
                const alignable = element;
                alignable.alignment = { x: a.newAlignment.x, y: a.newAlignment.y };
            }
        }
    }
}
exports.applyBounds = applyBounds;
/**
 * Model element types can include a colon to separate the basic type and a sub-type. This function
 * extracts the basic type of a model element.
 */
function getBasicType(element) {
    if (!element.type) {
        return '';
    }
    const colonIndex = element.type.indexOf(':');
    return colonIndex >= 0 ? element.type.substring(0, colonIndex) : element.type;
}
exports.getBasicType = getBasicType;
/**
 * Model element types can include a colon to separate the basic type and a sub-type. This function
 * extracts the sub-type of a model element.
 */
function getSubType(schema) {
    if (!schema.type) {
        return '';
    }
    const colonIndex = schema.type.indexOf(':');
    return colonIndex >= 0 ? schema.type.substring(colonIndex + 1) : schema.type;
}
exports.getSubType = getSubType;
/**
 * Find the element with the given identifier. If you need to find multiple elements, using an
 * `SModelIndex` might be more effective.
 */
function findElement(parent, elementId) {
    if (parent.id === elementId) {
        return parent;
    }
    if (parent.children) {
        for (const child of parent.children) {
            const result = findElement(child, elementId);
            if (result !== undefined) {
                return result;
            }
        }
    }
    return undefined;
}
exports.findElement = findElement;
/**
 * Used to speed up model element lookup by id.
 * This index implementation is for the serializable _external model_ defined in `sprotty-protocol`.
 */
class SModelIndex {
    constructor() {
        this.id2element = new Map();
        this.id2parent = new Map();
    }
    add(element) {
        if (!element.id) {
            throw new Error("Model element has no ID.");
        }
        else if (this.contains(element)) {
            throw new Error("Duplicate ID in model: " + element.id);
        }
        this.id2element.set(element.id, element);
        if (Array.isArray(element.children)) {
            for (const child of element.children) {
                this.add(child);
                this.id2parent.set(child.id, element);
            }
        }
        return this;
    }
    remove(element) {
        this.id2element.delete(element.id);
        if (Array.isArray(element.children)) {
            for (const child of element.children) {
                this.id2parent.delete(child.id);
                this.remove(child);
            }
        }
        return this;
    }
    contains(element) {
        return this.id2element.has(element.id);
    }
    getById(id) {
        return this.id2element.get(id);
    }
    getParent(id) {
        return this.id2parent.get(id);
    }
    getRoot(element) {
        let current = element;
        while (current) {
            const parent = this.id2parent.get(current.id);
            if (parent === undefined) {
                return current;
            }
            current = parent;
        }
        throw new Error("Element has no root");
    }
}
exports.SModelIndex = SModelIndex;


/***/ }),

/***/ "./node_modules/sprotty-protocol/lib/utils/object.js":
/*!***********************************************************!*\
  !*** ./node_modules/sprotty-protocol/lib/utils/object.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {


/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeAssign = exports.hasOwnProperty = exports.isObject = void 0;
function isObject(data) {
    return typeof data === 'object' && data !== null;
}
exports.isObject = isObject;
function hasOwnProperty(arg, key, type) {
    if (!isObject(arg)) {
        return false;
    }
    if (Array.isArray(key)) {
        for (const k of key) {
            if (!Object.prototype.hasOwnProperty.call(arg, k)) {
                return false;
            }
            if (typeof type === 'string' && typeof arg[k] !== type) {
                return false;
            }
            else if (typeof type === 'function' && !type(arg[k])) {
                return false;
            }
        }
    }
    else {
        if (!Object.prototype.hasOwnProperty.call(arg, key)) {
            return false;
        }
        if (typeof type === 'string') {
            return typeof arg[key] === type;
        }
        if (typeof type === 'function') {
            return type(arg[key]);
        }
    }
    return true;
}
exports.hasOwnProperty = hasOwnProperty;
function safeAssign(target, partial) {
    return Object.assign(target, partial);
}
exports.safeAssign = safeAssign;


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_sprotty-protocol_lib_actions_js-node_modules_sprotty-protocol_lib_utils_-67982b.e1001882bbdbba061e50.js.map?v=e1001882bbdbba061e50