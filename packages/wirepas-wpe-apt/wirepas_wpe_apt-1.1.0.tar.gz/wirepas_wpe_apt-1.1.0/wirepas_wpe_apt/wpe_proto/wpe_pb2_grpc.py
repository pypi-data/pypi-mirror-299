# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from . import wpe_pb2 as wpe__pb2

GRPC_GENERATED_VERSION = '1.64.0'
GRPC_VERSION = grpc.__version__
EXPECTED_ERROR_RELEASE = '1.65.0'
SCHEDULED_RELEASE_DATE = 'June 25, 2024'
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    warnings.warn(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in wpe_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
        + f' This warning will become an error in {EXPECTED_ERROR_RELEASE},'
        + f' scheduled for release on {SCHEDULED_RELEASE_DATE}.',
        RuntimeWarning
    )


class flow_managerStub(object):
    """*
    Flow manager's service definition.

    This is _the_ public interface for WPE and the one to
    be versioned and maintained.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.stop = channel.unary_unary(
                '/wirepas.wpe.flow_manager/stop',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.status = channel.unary_unary(
                '/wirepas.wpe.flow_manager/status',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.purge = channel.unary_unary(
                '/wirepas.wpe.flow_manager/purge',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.configure = channel.stream_unary(
                '/wirepas.wpe.flow_manager/configure',
                request_serializer=wpe__pb2.ConfigurationData.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.fetch = channel.unary_unary(
                '/wirepas.wpe.flow_manager/fetch',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.ConfigurationData.FromString,
                _registered_method=True)
        self.locate = channel.stream_stream(
                '/wirepas.wpe.flow_manager/locate',
                request_serializer=wpe__pb2.MeshData.SerializeToString,
                response_deserializer=wpe__pb2.Node.FromString,
                _registered_method=True)
        self.subscribe = channel.unary_unary(
                '/wirepas.wpe.flow_manager/subscribe',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.unsubscribe = channel.unary_unary(
                '/wirepas.wpe.flow_manager/unsubscribe',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.observe = channel.unary_stream(
                '/wirepas.wpe.flow_manager/observe',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Node.FromString,
                _registered_method=True)


class flow_managerServicer(object):
    """*
    Flow manager's service definition.

    This is _the_ public interface for WPE and the one to
    be versioned and maintained.
    """

    def stop(self, request, context):
        """*
        Requests the service to stop.

        Args:
        Query: with an empty payload.

        Returns:
        Status: information on when the shutdown will happen.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def status(self, request, context):
        """*
        Queries the status of a service - useful to check if a service is available.

        Args:
        Query: with an empty payload.

        Returns:
        Status: provides status and runtime information about the process.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def purge(self, request, context):
        """*
        Wipes in memory storage regarding a given network.

        Args:
        Query: with the target network id.

        Returns:
        Status: request sucess.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def configure(self, request_iterator, context):
        """*
        Receives updates on nodes and areas, storing it in the local memory.

        Note that if a Node or Area is already cached, its configuration will be
        updated not replaced, but initial data must contain coordinates.

        Args:
        Stream(ConfigurationData.network): network id.
        Stream(ConfigurationData.nodes): nodes with known location.
        Stream(ConfigurationData.areas): area definition.

        Returns:
        Status: request sucess.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def fetch(self, request, context):
        """*
        Retrieves the configuration for a given network id.

        Args:
        Query.network : network of interest.

        Returns:
        stream(ConfigurationData) : stream of the current configuration.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def locate(self, request_iterator, context):
        """*
        Talks with the core to request a new positioning for the reporter.

        Args:
        Stream(MeshData) : stream of MeshData.

        Returns:
        Stream(Node) : stream of position updates.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def subscribe(self, request, context):
        """*
        Registers to a service queue and obtains an id.

        Args:
        Query.network: network id whose events should be published.

        Returns:
        Status: information on the request.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def unsubscribe(self, request, context):
        """*
        Deregisters from the service queue.

        Args:
        Query.subscriber_id: id provided by the call to subscribe.

        Returns:
        Status: request sucess.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def observe(self, request, context):
        """*
        Obtains location updates flowing out of the service.

        Args:
        Query.subscriber_id: id provided by the call to subscribe.
        Query.network: specify network id if you want to receive the current node configuration.

        Returns:
        Stream(Node): stream of location updates.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_flow_managerServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'stop': grpc.unary_unary_rpc_method_handler(
                    servicer.stop,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'status': grpc.unary_unary_rpc_method_handler(
                    servicer.status,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'purge': grpc.unary_unary_rpc_method_handler(
                    servicer.purge,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'configure': grpc.stream_unary_rpc_method_handler(
                    servicer.configure,
                    request_deserializer=wpe__pb2.ConfigurationData.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'fetch': grpc.unary_unary_rpc_method_handler(
                    servicer.fetch,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.ConfigurationData.SerializeToString,
            ),
            'locate': grpc.stream_stream_rpc_method_handler(
                    servicer.locate,
                    request_deserializer=wpe__pb2.MeshData.FromString,
                    response_serializer=wpe__pb2.Node.SerializeToString,
            ),
            'subscribe': grpc.unary_unary_rpc_method_handler(
                    servicer.subscribe,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'unsubscribe': grpc.unary_unary_rpc_method_handler(
                    servicer.unsubscribe,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'observe': grpc.unary_stream_rpc_method_handler(
                    servicer.observe,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Node.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'wirepas.wpe.flow_manager', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('wirepas.wpe.flow_manager', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class flow_manager(object):
    """*
    Flow manager's service definition.

    This is _the_ public interface for WPE and the one to
    be versioned and maintained.
    """

    @staticmethod
    def stop(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.flow_manager/stop',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def status(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.flow_manager/status',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def purge(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.flow_manager/purge',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def configure(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_unary(
            request_iterator,
            target,
            '/wirepas.wpe.flow_manager/configure',
            wpe__pb2.ConfigurationData.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def fetch(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.flow_manager/fetch',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.ConfigurationData.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def locate(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(
            request_iterator,
            target,
            '/wirepas.wpe.flow_manager/locate',
            wpe__pb2.MeshData.SerializeToString,
            wpe__pb2.Node.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def subscribe(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.flow_manager/subscribe',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def unsubscribe(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.flow_manager/unsubscribe',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def observe(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/wirepas.wpe.flow_manager/observe',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Node.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)


class log_managerStub(object):
    """*
    Log manager's service definition.

    This is a reference service able to read from one or multiple sources of
    data, such as databases and files.

    You should consider extending this service if you want to build your own
    API wrapper and provide live data into the flow manager.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.stop = channel.unary_unary(
                '/wirepas.wpe.log_manager/stop',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.status = channel.unary_unary(
                '/wirepas.wpe.log_manager/status',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.record = channel.stream_unary(
                '/wirepas.wpe.log_manager/record',
                request_serializer=wpe__pb2.Log.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)


class log_managerServicer(object):
    """*
    Log manager's service definition.

    This is a reference service able to read from one or multiple sources of
    data, such as databases and files.

    You should consider extending this service if you want to build your own
    API wrapper and provide live data into the flow manager.
    """

    def stop(self, request, context):
        """*
        Requests the service to stop.

        Args:
        Query: with an empty payload.

        Returns:
        Status: information on when the shutdown will happen.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def status(self, request, context):
        """*
        Queries the status of a service - useful to check if a service is available.

        Args:
        Query: with an empty payload.

        Returns:
        Status: provides status and runtime information about the process.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def record(self, request_iterator, context):
        """*
        Stores messages to the log file (if filepath defined on startup) or to stdout.

        Args:
        Stream(Log): stream of log messages.

        Returns:
        Status: provides status and runtime information about the process.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_log_managerServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'stop': grpc.unary_unary_rpc_method_handler(
                    servicer.stop,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'status': grpc.unary_unary_rpc_method_handler(
                    servicer.status,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'record': grpc.stream_unary_rpc_method_handler(
                    servicer.record,
                    request_deserializer=wpe__pb2.Log.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'wirepas.wpe.log_manager', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('wirepas.wpe.log_manager', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class log_manager(object):
    """*
    Log manager's service definition.

    This is a reference service able to read from one or multiple sources of
    data, such as databases and files.

    You should consider extending this service if you want to build your own
    API wrapper and provide live data into the flow manager.
    """

    @staticmethod
    def stop(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.log_manager/stop',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def status(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.log_manager/status',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def record(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_unary(
            request_iterator,
            target,
            '/wirepas.wpe.log_manager/record',
            wpe__pb2.Log.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)


class subscriber_managerStub(object):
    """*
    Subscriber manager service definition.

    This is _the_ public interface for WPE and the one to
    be versioned and maintained.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.stop = channel.unary_unary(
                '/wirepas.wpe.subscriber_manager/stop',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.status = channel.unary_unary(
                '/wirepas.wpe.subscriber_manager/status',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)
        self.fetch = channel.unary_unary(
                '/wirepas.wpe.subscriber_manager/fetch',
                request_serializer=wpe__pb2.Query.SerializeToString,
                response_deserializer=wpe__pb2.Status.FromString,
                _registered_method=True)


class subscriber_managerServicer(object):
    """*
    Subscriber manager service definition.

    This is _the_ public interface for WPE and the one to
    be versioned and maintained.
    """

    def stop(self, request, context):
        """*
        Requests the service to stop

        Args:
        Query: with an empty payload.

        Returns:
        Status: information on when the shutdown will happen.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def status(self, request, context):
        """*
        Queries the status of a service - useful to check if a service is available.

        Args:
        Query: with an empty payload.

        Returns:
        Status: provides status and runtime information about the process.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def fetch(self, request, context):
        """*
        Requests configuration data from the network.

        Args:
        Query: with an empty payload.

        Returns:
        Status: returns operation success.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_subscriber_managerServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'stop': grpc.unary_unary_rpc_method_handler(
                    servicer.stop,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'status': grpc.unary_unary_rpc_method_handler(
                    servicer.status,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
            'fetch': grpc.unary_unary_rpc_method_handler(
                    servicer.fetch,
                    request_deserializer=wpe__pb2.Query.FromString,
                    response_serializer=wpe__pb2.Status.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'wirepas.wpe.subscriber_manager', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('wirepas.wpe.subscriber_manager', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class subscriber_manager(object):
    """*
    Subscriber manager service definition.

    This is _the_ public interface for WPE and the one to
    be versioned and maintained.
    """

    @staticmethod
    def stop(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.subscriber_manager/stop',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def status(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.subscriber_manager/status',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def fetch(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/wirepas.wpe.subscriber_manager/fetch',
            wpe__pb2.Query.SerializeToString,
            wpe__pb2.Status.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
