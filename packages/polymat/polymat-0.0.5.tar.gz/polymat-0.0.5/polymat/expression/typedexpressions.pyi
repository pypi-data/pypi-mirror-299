from typing import Iterable, overload

from polymat.expression.expression import Expression
from polymat.expressiontree.from_ import FromAnyTypes
from polymat.expressiontree.operations.combinations import Combinations
from polymat.expressiontree.operations.filterpredicator import FilterPredicate
from polymat.expressiontree.nodes import (
    ExpressionNode,
    SingleChildExpressionNode,
)
from polymat.expressiontree.operations.getitem import GetItem
from polymat.expressiontree.operations.product import Product
from polymat.expressiontree.operations.truncatemonomials import TruncateMonomials
from polymat.sparserepr.sparserepr import SparseRepr
from polymat.state import State
from polymat.symbol import Symbol

# The following classes are defined solely in the stub file for type checking and have no impact during code execution.

type VariableVectorType = VariableVectorExpression | tuple[int, ...]

class MatrixExpression(SingleChildExpressionNode):
    def __add__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __getitem__(self, key: GetItem.KeyType) -> PolynomialExpression: ...
    @overload
    def __matmul__(self, other: VectorExpression) -> VectorExpression: ...
    @overload
    def __matmul__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __mul__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __neg__(self) -> MatrixExpression: ...
    def __pow__(self, exponent: int) -> MatrixExpression: ...
    def __radd__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __rmul__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __rmatmul__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __rsub__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __sub__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __truediv__(self, other: float | int) -> MatrixExpression: ...
    def apply(self, state: State) -> tuple[State, SparseRepr]: ...
    def block_diag(self, others: Iterable[MatrixExpression]) -> MatrixExpression: ...
    def cache(self) -> MatrixExpression: ...
    def copy(self, child: ExpressionNode) -> MatrixExpression: ...
    def diff(self, variables: VariableVectorType) -> MatrixExpression: ...
    def eval(
        self, substitutions: Expression.SubstitutionType,
    ) -> MatrixExpression: ...
    def h_stack(self, others: Iterable[MatrixExpression]) -> MatrixExpression: ...
    def kron(self, other: MatrixExpression) -> MatrixExpression: ...
    def to_linear_monomials(
        self, variables: VariableVectorType
    ) -> MonomialVectorExpression: ...
    def to_quadratic_monomials(
        self, variables: VariableVectorType
    ) -> MonomialVectorExpression: ...
    def rep_mat(self, n: int, m: int) -> MatrixExpression: ...
    def reshape(self, n: int, m: int) -> MatrixExpression: ...
    def slice(
        self, slice: tuple[tuple[int, ...], tuple[int, ...]]
    ) -> MatrixExpression: ...
    def sum(self) -> VectorExpression: ...
    def symmetric(self) -> SymmetricMatrixExpression: ...
    @property
    def T(self) -> MatrixExpression: ...
    def to_polynomial(self) -> PolynomialExpression: ...
    def to_variable_vector(self) -> VariableVectorType: ...
    def to_vector(self) -> VectorExpression: ...
    def to_monomial_vector(self) -> MonomialVectorExpression: ...
    def truncate_monomials(
        self,
        variables: VariableVectorType,
        degrees: TruncateMonomials.DegreeType,
    ) -> MatrixExpression: ...
    def v_stack(self, others: Iterable[MatrixExpression]) -> MatrixExpression: ...

class SymmetricMatrixExpression(MatrixExpression):
    @overload
    def __add__(
        self, other: SymmetricMatrixExpression
    ) -> SymmetricMatrixExpression: ...
    @overload
    def __add__(self, other: FromAnyTypes) -> MatrixExpression: ...
    @overload
    def __matmul__(self, other: VectorExpression) -> VectorExpression: ...
    @overload
    def __matmul__(
        self, other: SymmetricMatrixExpression
    ) -> SymmetricMatrixExpression: ...
    @overload
    def __matmul__(self, other: FromAnyTypes) -> MatrixExpression: ...
    @overload
    def __mul__(
        self, other: SymmetricMatrixExpression
    ) -> SymmetricMatrixExpression: ...
    @overload
    def __mul__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __neg__(self) -> SymmetricMatrixExpression: ...
    def __pow__(self, exponent: int) -> SymmetricMatrixExpression: ...
    def __radd__(self, other: FromAnyTypes) -> SymmetricMatrixExpression: ...
    def __rmul__(self, other: FromAnyTypes) -> SymmetricMatrixExpression: ...
    def __rsub__(self, other: FromAnyTypes) -> SymmetricMatrixExpression: ...
    @overload
    def __sub__(
        self, other: SymmetricMatrixExpression
    ) -> SymmetricMatrixExpression: ...
    @overload
    def __sub__(self, other: FromAnyTypes) -> MatrixExpression: ...
    @overload
    def block_diag(
        self, others: Iterable[SymmetricMatrixExpression]
    ) -> SymmetricMatrixExpression: ...
    @overload
    def block_diag(self, others: Iterable[MatrixExpression]) -> MatrixExpression: ...
    def cache(self) -> SymmetricMatrixExpression: ...
    def copy(self, child: ExpressionNode) -> SymmetricMatrixExpression: ...
    def diag(self) -> VectorExpression: ...
    def diff(self, variables: VariableVectorType) -> SymmetricMatrixExpression: ...
    def eval(
        self, substitutions: Expression.SubstitutionType,
    ) -> SymmetricMatrixExpression: ...
    @overload
    def kron(self, other: SymmetricMatrixExpression) -> SymmetricMatrixExpression: ...
    @overload
    def kron(self, other: MatrixExpression) -> MatrixExpression: ...
    @property
    def T(self) -> SymmetricMatrixExpression: ...
    def trace(self) -> PolynomialExpression: ...
    def truncate_monomials(
        self, variables: VariableVectorType, degrees: TruncateMonomials.DegreeType
    ) -> SymmetricMatrixExpression: ...

class VectorExpression(MatrixExpression):
    def __add__(self, other: FromAnyTypes) -> VectorExpression: ...
    def __mul__(self, other: FromAnyTypes) -> VectorExpression: ...
    def __neg__(self) -> VectorExpression: ...
    def __pow__(self, exponent: int) -> VectorExpression: ...
    def __radd__(self, other: FromAnyTypes) -> VectorExpression: ...
    @overload
    def __matmul__(self, other: RowVectorExpression) -> SymmetricMatrixExpression: ...
    @overload
    def __matmul__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __rmul__(self, other: FromAnyTypes) -> VectorExpression: ...
    def __rsub__(self, other: FromAnyTypes) -> VectorExpression: ...
    def __sub__(self, other: FromAnyTypes) -> VectorExpression: ...
    def __truediv__(self, other: float | int) -> VectorExpression: ...
    def cache(self) -> VectorExpression: ...
    def combinations(self, degrees: Combinations.DegreeType) -> VectorExpression: ...
    def copy(self, child: ExpressionNode) -> VectorExpression: ...
    def diag(self) -> SymmetricMatrixExpression: ...
    def diff(self, variables: VariableVectorType) -> VectorExpression: ...
    def eval(
        self, substitutions: Expression.SubstitutionType,
    ) -> VectorExpression: ...
    def filter_predicate(
        self, predicate: FilterPredicate.PredicatorType
    ) -> VectorExpression: ...
    def filter_non_zero(self) -> VectorExpression: ...
    @overload
    def kron(self, other: VectorExpression) -> VectorExpression: ...
    @overload
    def kron(self, other: MatrixExpression) -> MatrixExpression: ...
    def to_linear_coefficients(
        self,
        variables: VariableVectorType,
        monomials: MonomialVectorExpression | None = None,
    ) -> MatrixExpression: ...
    def parametrize(self, variable: Symbol | str) -> VariableExpression: ...
    def product(
        self,
        others: Iterable[VectorExpression],
        degrees: Product.DegreeType = None,
    ) -> VectorExpression: ...
    def sum(self) -> PolynomialExpression: ...
    def v_stack(self, others: Iterable[VectorExpression]) -> VectorExpression: ...
    @property
    def T(self) -> RowVectorExpression: ...
    def truncate_monomials(
        self, 
        variables: VariableVectorType, 
        degrees: TruncateMonomials.DegreeType
    ) -> VectorExpression: ...

class RowVectorExpression(MatrixExpression):
    def __add__(self, other: FromAnyTypes) -> RowVectorExpression: ...
    def __mul__(self, other: FromAnyTypes) -> RowVectorExpression: ...
    def __neg__(self) -> RowVectorExpression: ...
    def __pow__(self, exponent: int) -> RowVectorExpression: ...
    def __radd__(self, other: FromAnyTypes) -> RowVectorExpression: ...
    @overload
    def __matmul__(self, other: SymmetricMatrixExpression) -> RowVectorExpression: ...
    @overload
    def __matmul__(self, other: VectorExpression) -> PolynomialExpression: ...
    @overload
    def __matmul__(self, other: FromAnyTypes) -> MatrixExpression: ...
    def __rmul__(self, other: FromAnyTypes) -> RowVectorExpression: ...
    def __rsub__(self, other: FromAnyTypes) -> RowVectorExpression: ...
    def __sub__(self, other: FromAnyTypes) -> RowVectorExpression: ...
    def __truediv__(self, other: float | int) -> RowVectorExpression: ...
    def cache(self) -> RowVectorExpression: ...
    def copy(self, child: ExpressionNode) -> RowVectorExpression: ...
    def diff(self, variables: VariableVectorType) -> RowVectorExpression: ...
    def eval(
        self, substitutions: Expression.SubstitutionType,
    ) -> RowVectorExpression: ...
    def h_stack(self, others: Iterable[RowVectorExpression]) -> RowVectorExpression: ...
    @overload
    def kron(self, other: VectorExpression) -> RowVectorExpression: ...
    @overload
    def kron(self, other: MatrixExpression) -> MatrixExpression: ...
    def sum(self) -> PolynomialExpression: ...
    @property
    def T(self) -> VectorExpression: ...
    def truncate_monomials(
        self, 
        variables: VariableVectorType, 
        degrees: TruncateMonomials.DegreeType
    ) -> RowVectorExpression: ...

class PolynomialExpression(VectorExpression):
    def __add__(self, other: FromAnyTypes) -> PolynomialExpression: ...
    def __mul__(self, other: FromAnyTypes) -> PolynomialExpression: ...
    def __neg__(self) -> PolynomialExpression: ...
    def __pow__(self, exponent: int) -> PolynomialExpression: ...
    def __radd__(self, other: FromAnyTypes) -> PolynomialExpression: ...
    def __rmul__(self, other: FromAnyTypes) -> PolynomialExpression: ...
    def __rsub__(self, other: FromAnyTypes) -> PolynomialExpression: ...
    def __sub__(self, other: FromAnyTypes) -> PolynomialExpression: ...
    def __truediv__(self, other: float | int) -> PolynomialExpression: ...
    def cache(self) -> PolynomialExpression: ...
    def copy(self, child: ExpressionNode) -> PolynomialExpression: ...
    def diff(self, variables: VariableVectorType) -> RowVectorExpression: ...
    def eval(
        self, substitutions: Expression.SubstitutionType,
    ) -> PolynomialExpression: ...
    def h_stack(self, others: Iterable[MatrixExpression]) -> RowVectorExpression: ...
    def to_linear_coefficients(
        self,
        variables: VariableVectorType,
        monomials: MonomialVectorExpression | None = None,
    ) -> RowVectorExpression: ...
    def to_gram_matrix(
        self,
        variables: VariableVectorType,
        monomials: MonomialVectorExpression | None = None,
    ) -> SymmetricMatrixExpression: ...
    def sum(self) -> PolynomialExpression: ...
    def truncate_monomials(
        self, 
        variables: VariableVectorType, 
        degrees: TruncateMonomials.DegreeType
    ) -> PolynomialExpression: ...

class MonomialVectorExpression(VectorExpression):
    @overload
    def __mul__(self, other: MonomialVectorExpression) -> MonomialVectorExpression: ...
    @overload
    def __mul__(self, other: FromAnyTypes) -> VectorExpression: ...
    def __pow__(self, exponent: int) -> MonomialVectorExpression: ...
    def cache(self) -> MonomialVectorExpression: ...
    def copy(self, child: ExpressionNode) -> MonomialVectorExpression: ...
    def filter_predicate(
        self, predicate: FilterPredicate.PredicatorType
    ) -> MonomialVectorExpression: ...
    def filter_non_zero(self) -> MonomialVectorExpression: ...
    @overload
    def product(
        self,
        others: Iterable[MonomialVectorExpression],
        degrees: Product.DegreeType = None,
    ) -> MonomialVectorExpression: ...
    @overload
    def product(
        self,
        others: Iterable[VectorExpression],
        degrees: Product.DegreeType = None,
    ) -> VectorExpression: ...

class MonomialExpression(PolynomialExpression, MonomialVectorExpression):
    @overload
    def __mul__(self, other: MonomialExpression) -> MonomialExpression: ...
    @overload
    def __mul__(self, other: FromAnyTypes) -> PolynomialExpression: ...
    def __pow__(self, exponent: int) -> MonomialExpression: ...
    def cache(self) -> MonomialExpression: ...
    def copy(self, child: ExpressionNode) -> MonomialExpression: ...

class VariableVectorExpression(MonomialVectorExpression):
    def __pow__(self, exponent: int) -> MonomialVectorExpression: ...
    def cache(self) -> VariableVectorExpression: ...
    def combinations(
        self, degrees: Combinations.DegreeType
    ) -> MonomialVectorExpression: ...
    def copy(self, child: ExpressionNode) -> VariableVectorExpression: ...
    def filter_predicate(
        self, predicate: FilterPredicate.PredicatorType
    ) -> VariableVectorExpression: ...
    def filter_non_zero(self) -> VariableVectorExpression: ...

class VariableExpression(VariableVectorExpression):
    def cache(self) -> VariableExpression: ...
    def copy(self, child: ExpressionNode) -> VariableExpression: ...
    @property
    def symbol(self) -> Symbol: ...

class SingleValueVariableExpression(MonomialExpression, VariableExpression):
    def cache(self) -> SingleValueVariableExpression: ...
    def copy(self, child: ExpressionNode) -> SingleValueVariableExpression: ...
