from typing import Iterable, overload

from polymat.expression.typedexpressions import (
    MatrixExpression,
    RowVectorExpression,
    SymmetricMatrixExpression,
    VectorExpression,
    PolynomialExpression,
    SingleValueVariableExpression,
    VariableVectorExpression,
    VariableExpression,
)
from polymat.expressiontree.from_ import FromAnyTypes
from polymat.expressiontree.operations.fromany import FromAny
from polymat.expressiontree.operations.fromvariables import FromVariables
from polymat.expressiontree.operations.product import Product

@overload
def block_diag(expressions: Iterable[SymmetricMatrixExpression]) -> SymmetricMatrixExpression: ...
@overload
def block_diag(expressions: Iterable[MatrixExpression]) -> MatrixExpression: ...
def concat(expressions: Iterable[Iterable[MatrixExpression]]): ...
def from_(value: FromAnyTypes) -> MatrixExpression: ...
def from_symmetric(value: FromAnyTypes) -> SymmetricMatrixExpression: ...
def from_vector(value: FromAnyTypes) -> VectorExpression: ...
def from_row_vector(value: FromAnyTypes) -> RowVectorExpression: ...
def from_polynomial(value: FromAny.ValueType) -> PolynomialExpression: ...
@overload
def define_variable(
    name: str,
    size: int | MatrixExpression | None,
) -> VariableExpression: ...
@overload
def define_variable(
    name: str,
) -> SingleValueVariableExpression: ...
def from_variables(
    variables: FromVariables.VARIABLE_TYPE,
) -> VariableVectorExpression: ...
def from_variable_indices(indices: tuple[int, ...]) -> VariableVectorExpression: ...
@overload
def h_stack(expressions: Iterable[RowVectorExpression]) -> RowVectorExpression: ...
@overload
def h_stack(expressions: Iterable[MatrixExpression]) -> MatrixExpression: ...
def product(expressions: Iterable[VectorExpression], degrees: Product.DegreeType = None) -> VectorExpression: ...
@overload
def v_stack(expressions: Iterable[VariableExpression]) -> VariableVectorExpression: ...
@overload
def v_stack(
    expressions: Iterable[VariableVectorExpression],
) -> VariableVectorExpression: ...
@overload
def v_stack(expressions: Iterable[VectorExpression]) -> VectorExpression: ...
@overload
def v_stack(expressions: Iterable[MatrixExpression]) -> MatrixExpression: ...
