// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: graph_def.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_graph_5fdef_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_graph_5fdef_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "schema_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_graph_5fdef_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_graph_5fdef_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_graph_5fdef_2eproto;
namespace gs {
namespace rpc {
namespace graph {
class GraphDefPb;
struct GraphDefPbDefaultTypeInternal;
extern GraphDefPbDefaultTypeInternal _GraphDefPb_default_instance_;
class GraphDefPb_PropertyNameToIdEntry_DoNotUse;
struct GraphDefPb_PropertyNameToIdEntry_DoNotUseDefaultTypeInternal;
extern GraphDefPb_PropertyNameToIdEntry_DoNotUseDefaultTypeInternal _GraphDefPb_PropertyNameToIdEntry_DoNotUse_default_instance_;
class GrootInfoPb;
struct GrootInfoPbDefaultTypeInternal;
extern GrootInfoPbDefaultTypeInternal _GrootInfoPb_default_instance_;
class MutableGraphInfoPb;
struct MutableGraphInfoPbDefaultTypeInternal;
extern MutableGraphInfoPbDefaultTypeInternal _MutableGraphInfoPb_default_instance_;
class VineyardInfoPb;
struct VineyardInfoPbDefaultTypeInternal;
extern VineyardInfoPbDefaultTypeInternal _VineyardInfoPb_default_instance_;
}  // namespace graph
}  // namespace rpc
}  // namespace gs
PROTOBUF_NAMESPACE_OPEN
template<> ::gs::rpc::graph::GraphDefPb* Arena::CreateMaybeMessage<::gs::rpc::graph::GraphDefPb>(Arena*);
template<> ::gs::rpc::graph::GraphDefPb_PropertyNameToIdEntry_DoNotUse* Arena::CreateMaybeMessage<::gs::rpc::graph::GraphDefPb_PropertyNameToIdEntry_DoNotUse>(Arena*);
template<> ::gs::rpc::graph::GrootInfoPb* Arena::CreateMaybeMessage<::gs::rpc::graph::GrootInfoPb>(Arena*);
template<> ::gs::rpc::graph::MutableGraphInfoPb* Arena::CreateMaybeMessage<::gs::rpc::graph::MutableGraphInfoPb>(Arena*);
template<> ::gs::rpc::graph::VineyardInfoPb* Arena::CreateMaybeMessage<::gs::rpc::graph::VineyardInfoPb>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gs {
namespace rpc {
namespace graph {

enum GraphTypePb : int {
  UNKNOWN_TYPE = 0,
  IMMUTABLE_EDGECUT = 1,
  DYNAMIC_PROPERTY = 2,
  DYNAMIC_PROJECTED = 3,
  ARROW_PROPERTY = 4,
  ARROW_PROJECTED = 5,
  PERSISTENT_STORE = 6,
  ARROW_FLATTENED = 7,
  GraphTypePb_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GraphTypePb_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GraphTypePb_IsValid(int value);
constexpr GraphTypePb GraphTypePb_MIN = UNKNOWN_TYPE;
constexpr GraphTypePb GraphTypePb_MAX = ARROW_FLATTENED;
constexpr int GraphTypePb_ARRAYSIZE = GraphTypePb_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GraphTypePb_descriptor();
template<typename T>
inline const std::string& GraphTypePb_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GraphTypePb>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GraphTypePb_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GraphTypePb_descriptor(), enum_t_value);
}
inline bool GraphTypePb_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GraphTypePb* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GraphTypePb>(
    GraphTypePb_descriptor(), name, value);
}
enum VertexMapTypePb : int {
  UNKNOWN_VM_TYPE = 0,
  GLOBAL_VERTEX_MAP = 1,
  LOCAL_VERTEX_MAP = 2,
  VertexMapTypePb_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VertexMapTypePb_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VertexMapTypePb_IsValid(int value);
constexpr VertexMapTypePb VertexMapTypePb_MIN = UNKNOWN_VM_TYPE;
constexpr VertexMapTypePb VertexMapTypePb_MAX = LOCAL_VERTEX_MAP;
constexpr int VertexMapTypePb_ARRAYSIZE = VertexMapTypePb_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VertexMapTypePb_descriptor();
template<typename T>
inline const std::string& VertexMapTypePb_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VertexMapTypePb>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VertexMapTypePb_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VertexMapTypePb_descriptor(), enum_t_value);
}
inline bool VertexMapTypePb_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VertexMapTypePb* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VertexMapTypePb>(
    VertexMapTypePb_descriptor(), name, value);
}
// ===================================================================

class GrootInfoPb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gs.rpc.graph.GrootInfoPb) */ {
 public:
  inline GrootInfoPb() : GrootInfoPb(nullptr) {}
  ~GrootInfoPb() override;
  explicit PROTOBUF_CONSTEXPR GrootInfoPb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrootInfoPb(const GrootInfoPb& from);
  GrootInfoPb(GrootInfoPb&& from) noexcept
    : GrootInfoPb() {
    *this = ::std::move(from);
  }

  inline GrootInfoPb& operator=(const GrootInfoPb& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrootInfoPb& operator=(GrootInfoPb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrootInfoPb& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrootInfoPb* internal_default_instance() {
    return reinterpret_cast<const GrootInfoPb*>(
               &_GrootInfoPb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GrootInfoPb& a, GrootInfoPb& b) {
    a.Swap(&b);
  }
  inline void Swap(GrootInfoPb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrootInfoPb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrootInfoPb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrootInfoPb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrootInfoPb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrootInfoPb& from) {
    GrootInfoPb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrootInfoPb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gs.rpc.graph.GrootInfoPb";
  }
  protected:
  explicit GrootInfoPb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastLabelIdFieldNumber = 1,
    kLastPropertyIdFieldNumber = 2,
    kLastTableIdFieldNumber = 3,
  };
  // int32 last_label_id = 1;
  void clear_last_label_id();
  int32_t last_label_id() const;
  void set_last_label_id(int32_t value);
  private:
  int32_t _internal_last_label_id() const;
  void _internal_set_last_label_id(int32_t value);
  public:

  // int32 last_property_id = 2;
  void clear_last_property_id();
  int32_t last_property_id() const;
  void set_last_property_id(int32_t value);
  private:
  int32_t _internal_last_property_id() const;
  void _internal_set_last_property_id(int32_t value);
  public:

  // int64 last_table_id = 3;
  void clear_last_table_id();
  int64_t last_table_id() const;
  void set_last_table_id(int64_t value);
  private:
  int64_t _internal_last_table_id() const;
  void _internal_set_last_table_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gs.rpc.graph.GrootInfoPb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t last_label_id_;
    int32_t last_property_id_;
    int64_t last_table_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_5fdef_2eproto;
};
// -------------------------------------------------------------------

class VineyardInfoPb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gs.rpc.graph.VineyardInfoPb) */ {
 public:
  inline VineyardInfoPb() : VineyardInfoPb(nullptr) {}
  ~VineyardInfoPb() override;
  explicit PROTOBUF_CONSTEXPR VineyardInfoPb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VineyardInfoPb(const VineyardInfoPb& from);
  VineyardInfoPb(VineyardInfoPb&& from) noexcept
    : VineyardInfoPb() {
    *this = ::std::move(from);
  }

  inline VineyardInfoPb& operator=(const VineyardInfoPb& from) {
    CopyFrom(from);
    return *this;
  }
  inline VineyardInfoPb& operator=(VineyardInfoPb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VineyardInfoPb& default_instance() {
    return *internal_default_instance();
  }
  static inline const VineyardInfoPb* internal_default_instance() {
    return reinterpret_cast<const VineyardInfoPb*>(
               &_VineyardInfoPb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VineyardInfoPb& a, VineyardInfoPb& b) {
    a.Swap(&b);
  }
  inline void Swap(VineyardInfoPb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VineyardInfoPb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VineyardInfoPb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VineyardInfoPb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VineyardInfoPb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VineyardInfoPb& from) {
    VineyardInfoPb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VineyardInfoPb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gs.rpc.graph.VineyardInfoPb";
  }
  protected:
  explicit VineyardInfoPb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentsFieldNumber = 10,
    kSchemaPathFieldNumber = 5,
    kPropertySchemaJsonFieldNumber = 8,
    kOidTypeFieldNumber = 1,
    kVidTypeFieldNumber = 2,
    kVdataTypeFieldNumber = 3,
    kEdataTypeFieldNumber = 4,
    kVineyardIdFieldNumber = 7,
    kGenerateEidFieldNumber = 6,
    kRetainOidFieldNumber = 11,
    kVertexMapTypeFieldNumber = 9,
  };
  // repeated int64 fragments = 10;
  int fragments_size() const;
  private:
  int _internal_fragments_size() const;
  public:
  void clear_fragments();
  private:
  int64_t _internal_fragments(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_fragments() const;
  void _internal_add_fragments(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_fragments();
  public:
  int64_t fragments(int index) const;
  void set_fragments(int index, int64_t value);
  void add_fragments(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      fragments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_fragments();

  // string schema_path = 5;
  void clear_schema_path();
  const std::string& schema_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_path();
  PROTOBUF_NODISCARD std::string* release_schema_path();
  void set_allocated_schema_path(std::string* schema_path);
  private:
  const std::string& _internal_schema_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_path(const std::string& value);
  std::string* _internal_mutable_schema_path();
  public:

  // string property_schema_json = 8;
  void clear_property_schema_json();
  const std::string& property_schema_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_property_schema_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_property_schema_json();
  PROTOBUF_NODISCARD std::string* release_property_schema_json();
  void set_allocated_property_schema_json(std::string* property_schema_json);
  private:
  const std::string& _internal_property_schema_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_property_schema_json(const std::string& value);
  std::string* _internal_mutable_property_schema_json();
  public:

  // .gs.rpc.graph.DataTypePb oid_type = 1;
  void clear_oid_type();
  ::gs::rpc::graph::DataTypePb oid_type() const;
  void set_oid_type(::gs::rpc::graph::DataTypePb value);
  private:
  ::gs::rpc::graph::DataTypePb _internal_oid_type() const;
  void _internal_set_oid_type(::gs::rpc::graph::DataTypePb value);
  public:

  // .gs.rpc.graph.DataTypePb vid_type = 2;
  void clear_vid_type();
  ::gs::rpc::graph::DataTypePb vid_type() const;
  void set_vid_type(::gs::rpc::graph::DataTypePb value);
  private:
  ::gs::rpc::graph::DataTypePb _internal_vid_type() const;
  void _internal_set_vid_type(::gs::rpc::graph::DataTypePb value);
  public:

  // .gs.rpc.graph.DataTypePb vdata_type = 3;
  void clear_vdata_type();
  ::gs::rpc::graph::DataTypePb vdata_type() const;
  void set_vdata_type(::gs::rpc::graph::DataTypePb value);
  private:
  ::gs::rpc::graph::DataTypePb _internal_vdata_type() const;
  void _internal_set_vdata_type(::gs::rpc::graph::DataTypePb value);
  public:

  // .gs.rpc.graph.DataTypePb edata_type = 4;
  void clear_edata_type();
  ::gs::rpc::graph::DataTypePb edata_type() const;
  void set_edata_type(::gs::rpc::graph::DataTypePb value);
  private:
  ::gs::rpc::graph::DataTypePb _internal_edata_type() const;
  void _internal_set_edata_type(::gs::rpc::graph::DataTypePb value);
  public:

  // int64 vineyard_id = 7;
  void clear_vineyard_id();
  int64_t vineyard_id() const;
  void set_vineyard_id(int64_t value);
  private:
  int64_t _internal_vineyard_id() const;
  void _internal_set_vineyard_id(int64_t value);
  public:

  // bool generate_eid = 6;
  void clear_generate_eid();
  bool generate_eid() const;
  void set_generate_eid(bool value);
  private:
  bool _internal_generate_eid() const;
  void _internal_set_generate_eid(bool value);
  public:

  // bool retain_oid = 11;
  void clear_retain_oid();
  bool retain_oid() const;
  void set_retain_oid(bool value);
  private:
  bool _internal_retain_oid() const;
  void _internal_set_retain_oid(bool value);
  public:

  // .gs.rpc.graph.VertexMapTypePb vertex_map_type = 9;
  void clear_vertex_map_type();
  ::gs::rpc::graph::VertexMapTypePb vertex_map_type() const;
  void set_vertex_map_type(::gs::rpc::graph::VertexMapTypePb value);
  private:
  ::gs::rpc::graph::VertexMapTypePb _internal_vertex_map_type() const;
  void _internal_set_vertex_map_type(::gs::rpc::graph::VertexMapTypePb value);
  public:

  // @@protoc_insertion_point(class_scope:gs.rpc.graph.VineyardInfoPb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > fragments_;
    mutable std::atomic<int> _fragments_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr property_schema_json_;
    int oid_type_;
    int vid_type_;
    int vdata_type_;
    int edata_type_;
    int64_t vineyard_id_;
    bool generate_eid_;
    bool retain_oid_;
    int vertex_map_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_5fdef_2eproto;
};
// -------------------------------------------------------------------

class MutableGraphInfoPb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gs.rpc.graph.MutableGraphInfoPb) */ {
 public:
  inline MutableGraphInfoPb() : MutableGraphInfoPb(nullptr) {}
  ~MutableGraphInfoPb() override;
  explicit PROTOBUF_CONSTEXPR MutableGraphInfoPb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MutableGraphInfoPb(const MutableGraphInfoPb& from);
  MutableGraphInfoPb(MutableGraphInfoPb&& from) noexcept
    : MutableGraphInfoPb() {
    *this = ::std::move(from);
  }

  inline MutableGraphInfoPb& operator=(const MutableGraphInfoPb& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutableGraphInfoPb& operator=(MutableGraphInfoPb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MutableGraphInfoPb& default_instance() {
    return *internal_default_instance();
  }
  static inline const MutableGraphInfoPb* internal_default_instance() {
    return reinterpret_cast<const MutableGraphInfoPb*>(
               &_MutableGraphInfoPb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MutableGraphInfoPb& a, MutableGraphInfoPb& b) {
    a.Swap(&b);
  }
  inline void Swap(MutableGraphInfoPb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutableGraphInfoPb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MutableGraphInfoPb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MutableGraphInfoPb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MutableGraphInfoPb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MutableGraphInfoPb& from) {
    MutableGraphInfoPb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutableGraphInfoPb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gs.rpc.graph.MutableGraphInfoPb";
  }
  protected:
  explicit MutableGraphInfoPb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertySchemaJsonFieldNumber = 3,
    kVdataTypeFieldNumber = 1,
    kEdataTypeFieldNumber = 2,
  };
  // string property_schema_json = 3;
  void clear_property_schema_json();
  const std::string& property_schema_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_property_schema_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_property_schema_json();
  PROTOBUF_NODISCARD std::string* release_property_schema_json();
  void set_allocated_property_schema_json(std::string* property_schema_json);
  private:
  const std::string& _internal_property_schema_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_property_schema_json(const std::string& value);
  std::string* _internal_mutable_property_schema_json();
  public:

  // .gs.rpc.graph.DataTypePb vdata_type = 1;
  void clear_vdata_type();
  ::gs::rpc::graph::DataTypePb vdata_type() const;
  void set_vdata_type(::gs::rpc::graph::DataTypePb value);
  private:
  ::gs::rpc::graph::DataTypePb _internal_vdata_type() const;
  void _internal_set_vdata_type(::gs::rpc::graph::DataTypePb value);
  public:

  // .gs.rpc.graph.DataTypePb edata_type = 2;
  void clear_edata_type();
  ::gs::rpc::graph::DataTypePb edata_type() const;
  void set_edata_type(::gs::rpc::graph::DataTypePb value);
  private:
  ::gs::rpc::graph::DataTypePb _internal_edata_type() const;
  void _internal_set_edata_type(::gs::rpc::graph::DataTypePb value);
  public:

  // @@protoc_insertion_point(class_scope:gs.rpc.graph.MutableGraphInfoPb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr property_schema_json_;
    int vdata_type_;
    int edata_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_5fdef_2eproto;
};
// -------------------------------------------------------------------

class GraphDefPb_PropertyNameToIdEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GraphDefPb_PropertyNameToIdEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GraphDefPb_PropertyNameToIdEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  GraphDefPb_PropertyNameToIdEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GraphDefPb_PropertyNameToIdEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GraphDefPb_PropertyNameToIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GraphDefPb_PropertyNameToIdEntry_DoNotUse& other);
  static const GraphDefPb_PropertyNameToIdEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GraphDefPb_PropertyNameToIdEntry_DoNotUse*>(&_GraphDefPb_PropertyNameToIdEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "gs.rpc.graph.GraphDefPb.PropertyNameToIdEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_graph_5fdef_2eproto;
};

// -------------------------------------------------------------------

class GraphDefPb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gs.rpc.graph.GraphDefPb) */ {
 public:
  inline GraphDefPb() : GraphDefPb(nullptr) {}
  ~GraphDefPb() override;
  explicit PROTOBUF_CONSTEXPR GraphDefPb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphDefPb(const GraphDefPb& from);
  GraphDefPb(GraphDefPb&& from) noexcept
    : GraphDefPb() {
    *this = ::std::move(from);
  }

  inline GraphDefPb& operator=(const GraphDefPb& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphDefPb& operator=(GraphDefPb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphDefPb& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphDefPb* internal_default_instance() {
    return reinterpret_cast<const GraphDefPb*>(
               &_GraphDefPb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GraphDefPb& a, GraphDefPb& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphDefPb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphDefPb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphDefPb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphDefPb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphDefPb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GraphDefPb& from) {
    GraphDefPb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphDefPb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gs.rpc.graph.GraphDefPb";
  }
  protected:
  explicit GraphDefPb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTypeDefsFieldNumber = 5,
    kEdgeKindsFieldNumber = 6,
    kPropertyNameToIdFieldNumber = 7,
    kKeyFieldNumber = 2,
    kExtensionFieldNumber = 8,
    kVersionFieldNumber = 1,
    kGraphTypeFieldNumber = 3,
    kDirectedFieldNumber = 4,
    kIsMultigraphFieldNumber = 9,
    kCompactEdgesFieldNumber = 10,
    kUsePerfectHashFieldNumber = 11,
  };
  // repeated .gs.rpc.graph.TypeDefPb type_defs = 5;
  int type_defs_size() const;
  private:
  int _internal_type_defs_size() const;
  public:
  void clear_type_defs();
  ::gs::rpc::graph::TypeDefPb* mutable_type_defs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::TypeDefPb >*
      mutable_type_defs();
  private:
  const ::gs::rpc::graph::TypeDefPb& _internal_type_defs(int index) const;
  ::gs::rpc::graph::TypeDefPb* _internal_add_type_defs();
  public:
  const ::gs::rpc::graph::TypeDefPb& type_defs(int index) const;
  ::gs::rpc::graph::TypeDefPb* add_type_defs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::TypeDefPb >&
      type_defs() const;

  // repeated .gs.rpc.graph.EdgeKindPb edge_kinds = 6;
  int edge_kinds_size() const;
  private:
  int _internal_edge_kinds_size() const;
  public:
  void clear_edge_kinds();
  ::gs::rpc::graph::EdgeKindPb* mutable_edge_kinds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::EdgeKindPb >*
      mutable_edge_kinds();
  private:
  const ::gs::rpc::graph::EdgeKindPb& _internal_edge_kinds(int index) const;
  ::gs::rpc::graph::EdgeKindPb* _internal_add_edge_kinds();
  public:
  const ::gs::rpc::graph::EdgeKindPb& edge_kinds(int index) const;
  ::gs::rpc::graph::EdgeKindPb* add_edge_kinds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::EdgeKindPb >&
      edge_kinds() const;

  // map<string, int32> property_name_to_id = 7;
  int property_name_to_id_size() const;
  private:
  int _internal_property_name_to_id_size() const;
  public:
  void clear_property_name_to_id();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      _internal_property_name_to_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      _internal_mutable_property_name_to_id();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      property_name_to_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      mutable_property_name_to_id();

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .google.protobuf.Any extension = 8;
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;
  public:
  void clear_extension();
  const ::PROTOBUF_NAMESPACE_ID::Any& extension() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_extension();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_extension();
  void set_allocated_extension(::PROTOBUF_NAMESPACE_ID::Any* extension);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_extension() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_extension();
  public:
  void unsafe_arena_set_allocated_extension(
      ::PROTOBUF_NAMESPACE_ID::Any* extension);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_extension();

  // int64 version = 1;
  void clear_version();
  int64_t version() const;
  void set_version(int64_t value);
  private:
  int64_t _internal_version() const;
  void _internal_set_version(int64_t value);
  public:

  // .gs.rpc.graph.GraphTypePb graph_type = 3;
  void clear_graph_type();
  ::gs::rpc::graph::GraphTypePb graph_type() const;
  void set_graph_type(::gs::rpc::graph::GraphTypePb value);
  private:
  ::gs::rpc::graph::GraphTypePb _internal_graph_type() const;
  void _internal_set_graph_type(::gs::rpc::graph::GraphTypePb value);
  public:

  // bool directed = 4;
  void clear_directed();
  bool directed() const;
  void set_directed(bool value);
  private:
  bool _internal_directed() const;
  void _internal_set_directed(bool value);
  public:

  // bool is_multigraph = 9;
  void clear_is_multigraph();
  bool is_multigraph() const;
  void set_is_multigraph(bool value);
  private:
  bool _internal_is_multigraph() const;
  void _internal_set_is_multigraph(bool value);
  public:

  // bool compact_edges = 10;
  void clear_compact_edges();
  bool compact_edges() const;
  void set_compact_edges(bool value);
  private:
  bool _internal_compact_edges() const;
  void _internal_set_compact_edges(bool value);
  public:

  // bool use_perfect_hash = 11;
  void clear_use_perfect_hash();
  bool use_perfect_hash() const;
  void set_use_perfect_hash(bool value);
  private:
  bool _internal_use_perfect_hash() const;
  void _internal_set_use_perfect_hash(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gs.rpc.graph.GraphDefPb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::TypeDefPb > type_defs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::EdgeKindPb > edge_kinds_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GraphDefPb_PropertyNameToIdEntry_DoNotUse,
        std::string, int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> property_name_to_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::Any* extension_;
    int64_t version_;
    int graph_type_;
    bool directed_;
    bool is_multigraph_;
    bool compact_edges_;
    bool use_perfect_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_5fdef_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GrootInfoPb

// int32 last_label_id = 1;
inline void GrootInfoPb::clear_last_label_id() {
  _impl_.last_label_id_ = 0;
}
inline int32_t GrootInfoPb::_internal_last_label_id() const {
  return _impl_.last_label_id_;
}
inline int32_t GrootInfoPb::last_label_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GrootInfoPb.last_label_id)
  return _internal_last_label_id();
}
inline void GrootInfoPb::_internal_set_last_label_id(int32_t value) {
  
  _impl_.last_label_id_ = value;
}
inline void GrootInfoPb::set_last_label_id(int32_t value) {
  _internal_set_last_label_id(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GrootInfoPb.last_label_id)
}

// int32 last_property_id = 2;
inline void GrootInfoPb::clear_last_property_id() {
  _impl_.last_property_id_ = 0;
}
inline int32_t GrootInfoPb::_internal_last_property_id() const {
  return _impl_.last_property_id_;
}
inline int32_t GrootInfoPb::last_property_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GrootInfoPb.last_property_id)
  return _internal_last_property_id();
}
inline void GrootInfoPb::_internal_set_last_property_id(int32_t value) {
  
  _impl_.last_property_id_ = value;
}
inline void GrootInfoPb::set_last_property_id(int32_t value) {
  _internal_set_last_property_id(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GrootInfoPb.last_property_id)
}

// int64 last_table_id = 3;
inline void GrootInfoPb::clear_last_table_id() {
  _impl_.last_table_id_ = int64_t{0};
}
inline int64_t GrootInfoPb::_internal_last_table_id() const {
  return _impl_.last_table_id_;
}
inline int64_t GrootInfoPb::last_table_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GrootInfoPb.last_table_id)
  return _internal_last_table_id();
}
inline void GrootInfoPb::_internal_set_last_table_id(int64_t value) {
  
  _impl_.last_table_id_ = value;
}
inline void GrootInfoPb::set_last_table_id(int64_t value) {
  _internal_set_last_table_id(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GrootInfoPb.last_table_id)
}

// -------------------------------------------------------------------

// VineyardInfoPb

// .gs.rpc.graph.DataTypePb oid_type = 1;
inline void VineyardInfoPb::clear_oid_type() {
  _impl_.oid_type_ = 0;
}
inline ::gs::rpc::graph::DataTypePb VineyardInfoPb::_internal_oid_type() const {
  return static_cast< ::gs::rpc::graph::DataTypePb >(_impl_.oid_type_);
}
inline ::gs::rpc::graph::DataTypePb VineyardInfoPb::oid_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.oid_type)
  return _internal_oid_type();
}
inline void VineyardInfoPb::_internal_set_oid_type(::gs::rpc::graph::DataTypePb value) {
  
  _impl_.oid_type_ = value;
}
inline void VineyardInfoPb::set_oid_type(::gs::rpc::graph::DataTypePb value) {
  _internal_set_oid_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.oid_type)
}

// .gs.rpc.graph.DataTypePb vid_type = 2;
inline void VineyardInfoPb::clear_vid_type() {
  _impl_.vid_type_ = 0;
}
inline ::gs::rpc::graph::DataTypePb VineyardInfoPb::_internal_vid_type() const {
  return static_cast< ::gs::rpc::graph::DataTypePb >(_impl_.vid_type_);
}
inline ::gs::rpc::graph::DataTypePb VineyardInfoPb::vid_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.vid_type)
  return _internal_vid_type();
}
inline void VineyardInfoPb::_internal_set_vid_type(::gs::rpc::graph::DataTypePb value) {
  
  _impl_.vid_type_ = value;
}
inline void VineyardInfoPb::set_vid_type(::gs::rpc::graph::DataTypePb value) {
  _internal_set_vid_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.vid_type)
}

// .gs.rpc.graph.DataTypePb vdata_type = 3;
inline void VineyardInfoPb::clear_vdata_type() {
  _impl_.vdata_type_ = 0;
}
inline ::gs::rpc::graph::DataTypePb VineyardInfoPb::_internal_vdata_type() const {
  return static_cast< ::gs::rpc::graph::DataTypePb >(_impl_.vdata_type_);
}
inline ::gs::rpc::graph::DataTypePb VineyardInfoPb::vdata_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.vdata_type)
  return _internal_vdata_type();
}
inline void VineyardInfoPb::_internal_set_vdata_type(::gs::rpc::graph::DataTypePb value) {
  
  _impl_.vdata_type_ = value;
}
inline void VineyardInfoPb::set_vdata_type(::gs::rpc::graph::DataTypePb value) {
  _internal_set_vdata_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.vdata_type)
}

// .gs.rpc.graph.DataTypePb edata_type = 4;
inline void VineyardInfoPb::clear_edata_type() {
  _impl_.edata_type_ = 0;
}
inline ::gs::rpc::graph::DataTypePb VineyardInfoPb::_internal_edata_type() const {
  return static_cast< ::gs::rpc::graph::DataTypePb >(_impl_.edata_type_);
}
inline ::gs::rpc::graph::DataTypePb VineyardInfoPb::edata_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.edata_type)
  return _internal_edata_type();
}
inline void VineyardInfoPb::_internal_set_edata_type(::gs::rpc::graph::DataTypePb value) {
  
  _impl_.edata_type_ = value;
}
inline void VineyardInfoPb::set_edata_type(::gs::rpc::graph::DataTypePb value) {
  _internal_set_edata_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.edata_type)
}

// string schema_path = 5;
inline void VineyardInfoPb::clear_schema_path() {
  _impl_.schema_path_.ClearToEmpty();
}
inline const std::string& VineyardInfoPb::schema_path() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.schema_path)
  return _internal_schema_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VineyardInfoPb::set_schema_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.schema_path)
}
inline std::string* VineyardInfoPb::mutable_schema_path() {
  std::string* _s = _internal_mutable_schema_path();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.VineyardInfoPb.schema_path)
  return _s;
}
inline const std::string& VineyardInfoPb::_internal_schema_path() const {
  return _impl_.schema_path_.Get();
}
inline void VineyardInfoPb::_internal_set_schema_path(const std::string& value) {
  
  _impl_.schema_path_.Set(value, GetArenaForAllocation());
}
inline std::string* VineyardInfoPb::_internal_mutable_schema_path() {
  
  return _impl_.schema_path_.Mutable(GetArenaForAllocation());
}
inline std::string* VineyardInfoPb::release_schema_path() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.VineyardInfoPb.schema_path)
  return _impl_.schema_path_.Release();
}
inline void VineyardInfoPb::set_allocated_schema_path(std::string* schema_path) {
  if (schema_path != nullptr) {
    
  } else {
    
  }
  _impl_.schema_path_.SetAllocated(schema_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_path_.IsDefault()) {
    _impl_.schema_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.VineyardInfoPb.schema_path)
}

// bool generate_eid = 6;
inline void VineyardInfoPb::clear_generate_eid() {
  _impl_.generate_eid_ = false;
}
inline bool VineyardInfoPb::_internal_generate_eid() const {
  return _impl_.generate_eid_;
}
inline bool VineyardInfoPb::generate_eid() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.generate_eid)
  return _internal_generate_eid();
}
inline void VineyardInfoPb::_internal_set_generate_eid(bool value) {
  
  _impl_.generate_eid_ = value;
}
inline void VineyardInfoPb::set_generate_eid(bool value) {
  _internal_set_generate_eid(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.generate_eid)
}

// int64 vineyard_id = 7;
inline void VineyardInfoPb::clear_vineyard_id() {
  _impl_.vineyard_id_ = int64_t{0};
}
inline int64_t VineyardInfoPb::_internal_vineyard_id() const {
  return _impl_.vineyard_id_;
}
inline int64_t VineyardInfoPb::vineyard_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.vineyard_id)
  return _internal_vineyard_id();
}
inline void VineyardInfoPb::_internal_set_vineyard_id(int64_t value) {
  
  _impl_.vineyard_id_ = value;
}
inline void VineyardInfoPb::set_vineyard_id(int64_t value) {
  _internal_set_vineyard_id(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.vineyard_id)
}

// string property_schema_json = 8;
inline void VineyardInfoPb::clear_property_schema_json() {
  _impl_.property_schema_json_.ClearToEmpty();
}
inline const std::string& VineyardInfoPb::property_schema_json() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.property_schema_json)
  return _internal_property_schema_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VineyardInfoPb::set_property_schema_json(ArgT0&& arg0, ArgT... args) {
 
 _impl_.property_schema_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.property_schema_json)
}
inline std::string* VineyardInfoPb::mutable_property_schema_json() {
  std::string* _s = _internal_mutable_property_schema_json();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.VineyardInfoPb.property_schema_json)
  return _s;
}
inline const std::string& VineyardInfoPb::_internal_property_schema_json() const {
  return _impl_.property_schema_json_.Get();
}
inline void VineyardInfoPb::_internal_set_property_schema_json(const std::string& value) {
  
  _impl_.property_schema_json_.Set(value, GetArenaForAllocation());
}
inline std::string* VineyardInfoPb::_internal_mutable_property_schema_json() {
  
  return _impl_.property_schema_json_.Mutable(GetArenaForAllocation());
}
inline std::string* VineyardInfoPb::release_property_schema_json() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.VineyardInfoPb.property_schema_json)
  return _impl_.property_schema_json_.Release();
}
inline void VineyardInfoPb::set_allocated_property_schema_json(std::string* property_schema_json) {
  if (property_schema_json != nullptr) {
    
  } else {
    
  }
  _impl_.property_schema_json_.SetAllocated(property_schema_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.property_schema_json_.IsDefault()) {
    _impl_.property_schema_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.VineyardInfoPb.property_schema_json)
}

// .gs.rpc.graph.VertexMapTypePb vertex_map_type = 9;
inline void VineyardInfoPb::clear_vertex_map_type() {
  _impl_.vertex_map_type_ = 0;
}
inline ::gs::rpc::graph::VertexMapTypePb VineyardInfoPb::_internal_vertex_map_type() const {
  return static_cast< ::gs::rpc::graph::VertexMapTypePb >(_impl_.vertex_map_type_);
}
inline ::gs::rpc::graph::VertexMapTypePb VineyardInfoPb::vertex_map_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.vertex_map_type)
  return _internal_vertex_map_type();
}
inline void VineyardInfoPb::_internal_set_vertex_map_type(::gs::rpc::graph::VertexMapTypePb value) {
  
  _impl_.vertex_map_type_ = value;
}
inline void VineyardInfoPb::set_vertex_map_type(::gs::rpc::graph::VertexMapTypePb value) {
  _internal_set_vertex_map_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.vertex_map_type)
}

// repeated int64 fragments = 10;
inline int VineyardInfoPb::_internal_fragments_size() const {
  return _impl_.fragments_.size();
}
inline int VineyardInfoPb::fragments_size() const {
  return _internal_fragments_size();
}
inline void VineyardInfoPb::clear_fragments() {
  _impl_.fragments_.Clear();
}
inline int64_t VineyardInfoPb::_internal_fragments(int index) const {
  return _impl_.fragments_.Get(index);
}
inline int64_t VineyardInfoPb::fragments(int index) const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.fragments)
  return _internal_fragments(index);
}
inline void VineyardInfoPb::set_fragments(int index, int64_t value) {
  _impl_.fragments_.Set(index, value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.fragments)
}
inline void VineyardInfoPb::_internal_add_fragments(int64_t value) {
  _impl_.fragments_.Add(value);
}
inline void VineyardInfoPb::add_fragments(int64_t value) {
  _internal_add_fragments(value);
  // @@protoc_insertion_point(field_add:gs.rpc.graph.VineyardInfoPb.fragments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
VineyardInfoPb::_internal_fragments() const {
  return _impl_.fragments_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
VineyardInfoPb::fragments() const {
  // @@protoc_insertion_point(field_list:gs.rpc.graph.VineyardInfoPb.fragments)
  return _internal_fragments();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
VineyardInfoPb::_internal_mutable_fragments() {
  return &_impl_.fragments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
VineyardInfoPb::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:gs.rpc.graph.VineyardInfoPb.fragments)
  return _internal_mutable_fragments();
}

// bool retain_oid = 11;
inline void VineyardInfoPb::clear_retain_oid() {
  _impl_.retain_oid_ = false;
}
inline bool VineyardInfoPb::_internal_retain_oid() const {
  return _impl_.retain_oid_;
}
inline bool VineyardInfoPb::retain_oid() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.VineyardInfoPb.retain_oid)
  return _internal_retain_oid();
}
inline void VineyardInfoPb::_internal_set_retain_oid(bool value) {
  
  _impl_.retain_oid_ = value;
}
inline void VineyardInfoPb::set_retain_oid(bool value) {
  _internal_set_retain_oid(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.VineyardInfoPb.retain_oid)
}

// -------------------------------------------------------------------

// MutableGraphInfoPb

// .gs.rpc.graph.DataTypePb vdata_type = 1;
inline void MutableGraphInfoPb::clear_vdata_type() {
  _impl_.vdata_type_ = 0;
}
inline ::gs::rpc::graph::DataTypePb MutableGraphInfoPb::_internal_vdata_type() const {
  return static_cast< ::gs::rpc::graph::DataTypePb >(_impl_.vdata_type_);
}
inline ::gs::rpc::graph::DataTypePb MutableGraphInfoPb::vdata_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.MutableGraphInfoPb.vdata_type)
  return _internal_vdata_type();
}
inline void MutableGraphInfoPb::_internal_set_vdata_type(::gs::rpc::graph::DataTypePb value) {
  
  _impl_.vdata_type_ = value;
}
inline void MutableGraphInfoPb::set_vdata_type(::gs::rpc::graph::DataTypePb value) {
  _internal_set_vdata_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.MutableGraphInfoPb.vdata_type)
}

// .gs.rpc.graph.DataTypePb edata_type = 2;
inline void MutableGraphInfoPb::clear_edata_type() {
  _impl_.edata_type_ = 0;
}
inline ::gs::rpc::graph::DataTypePb MutableGraphInfoPb::_internal_edata_type() const {
  return static_cast< ::gs::rpc::graph::DataTypePb >(_impl_.edata_type_);
}
inline ::gs::rpc::graph::DataTypePb MutableGraphInfoPb::edata_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.MutableGraphInfoPb.edata_type)
  return _internal_edata_type();
}
inline void MutableGraphInfoPb::_internal_set_edata_type(::gs::rpc::graph::DataTypePb value) {
  
  _impl_.edata_type_ = value;
}
inline void MutableGraphInfoPb::set_edata_type(::gs::rpc::graph::DataTypePb value) {
  _internal_set_edata_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.MutableGraphInfoPb.edata_type)
}

// string property_schema_json = 3;
inline void MutableGraphInfoPb::clear_property_schema_json() {
  _impl_.property_schema_json_.ClearToEmpty();
}
inline const std::string& MutableGraphInfoPb::property_schema_json() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.MutableGraphInfoPb.property_schema_json)
  return _internal_property_schema_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MutableGraphInfoPb::set_property_schema_json(ArgT0&& arg0, ArgT... args) {
 
 _impl_.property_schema_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.MutableGraphInfoPb.property_schema_json)
}
inline std::string* MutableGraphInfoPb::mutable_property_schema_json() {
  std::string* _s = _internal_mutable_property_schema_json();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.MutableGraphInfoPb.property_schema_json)
  return _s;
}
inline const std::string& MutableGraphInfoPb::_internal_property_schema_json() const {
  return _impl_.property_schema_json_.Get();
}
inline void MutableGraphInfoPb::_internal_set_property_schema_json(const std::string& value) {
  
  _impl_.property_schema_json_.Set(value, GetArenaForAllocation());
}
inline std::string* MutableGraphInfoPb::_internal_mutable_property_schema_json() {
  
  return _impl_.property_schema_json_.Mutable(GetArenaForAllocation());
}
inline std::string* MutableGraphInfoPb::release_property_schema_json() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.MutableGraphInfoPb.property_schema_json)
  return _impl_.property_schema_json_.Release();
}
inline void MutableGraphInfoPb::set_allocated_property_schema_json(std::string* property_schema_json) {
  if (property_schema_json != nullptr) {
    
  } else {
    
  }
  _impl_.property_schema_json_.SetAllocated(property_schema_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.property_schema_json_.IsDefault()) {
    _impl_.property_schema_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.MutableGraphInfoPb.property_schema_json)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GraphDefPb

// int64 version = 1;
inline void GraphDefPb::clear_version() {
  _impl_.version_ = int64_t{0};
}
inline int64_t GraphDefPb::_internal_version() const {
  return _impl_.version_;
}
inline int64_t GraphDefPb::version() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.version)
  return _internal_version();
}
inline void GraphDefPb::_internal_set_version(int64_t value) {
  
  _impl_.version_ = value;
}
inline void GraphDefPb::set_version(int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GraphDefPb.version)
}

// string key = 2;
inline void GraphDefPb::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& GraphDefPb::key() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphDefPb::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GraphDefPb.key)
}
inline std::string* GraphDefPb::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.GraphDefPb.key)
  return _s;
}
inline const std::string& GraphDefPb::_internal_key() const {
  return _impl_.key_.Get();
}
inline void GraphDefPb::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphDefPb::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphDefPb::release_key() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.GraphDefPb.key)
  return _impl_.key_.Release();
}
inline void GraphDefPb::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.GraphDefPb.key)
}

// .gs.rpc.graph.GraphTypePb graph_type = 3;
inline void GraphDefPb::clear_graph_type() {
  _impl_.graph_type_ = 0;
}
inline ::gs::rpc::graph::GraphTypePb GraphDefPb::_internal_graph_type() const {
  return static_cast< ::gs::rpc::graph::GraphTypePb >(_impl_.graph_type_);
}
inline ::gs::rpc::graph::GraphTypePb GraphDefPb::graph_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.graph_type)
  return _internal_graph_type();
}
inline void GraphDefPb::_internal_set_graph_type(::gs::rpc::graph::GraphTypePb value) {
  
  _impl_.graph_type_ = value;
}
inline void GraphDefPb::set_graph_type(::gs::rpc::graph::GraphTypePb value) {
  _internal_set_graph_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GraphDefPb.graph_type)
}

// bool directed = 4;
inline void GraphDefPb::clear_directed() {
  _impl_.directed_ = false;
}
inline bool GraphDefPb::_internal_directed() const {
  return _impl_.directed_;
}
inline bool GraphDefPb::directed() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.directed)
  return _internal_directed();
}
inline void GraphDefPb::_internal_set_directed(bool value) {
  
  _impl_.directed_ = value;
}
inline void GraphDefPb::set_directed(bool value) {
  _internal_set_directed(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GraphDefPb.directed)
}

// repeated .gs.rpc.graph.TypeDefPb type_defs = 5;
inline int GraphDefPb::_internal_type_defs_size() const {
  return _impl_.type_defs_.size();
}
inline int GraphDefPb::type_defs_size() const {
  return _internal_type_defs_size();
}
inline ::gs::rpc::graph::TypeDefPb* GraphDefPb::mutable_type_defs(int index) {
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.GraphDefPb.type_defs)
  return _impl_.type_defs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::TypeDefPb >*
GraphDefPb::mutable_type_defs() {
  // @@protoc_insertion_point(field_mutable_list:gs.rpc.graph.GraphDefPb.type_defs)
  return &_impl_.type_defs_;
}
inline const ::gs::rpc::graph::TypeDefPb& GraphDefPb::_internal_type_defs(int index) const {
  return _impl_.type_defs_.Get(index);
}
inline const ::gs::rpc::graph::TypeDefPb& GraphDefPb::type_defs(int index) const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.type_defs)
  return _internal_type_defs(index);
}
inline ::gs::rpc::graph::TypeDefPb* GraphDefPb::_internal_add_type_defs() {
  return _impl_.type_defs_.Add();
}
inline ::gs::rpc::graph::TypeDefPb* GraphDefPb::add_type_defs() {
  ::gs::rpc::graph::TypeDefPb* _add = _internal_add_type_defs();
  // @@protoc_insertion_point(field_add:gs.rpc.graph.GraphDefPb.type_defs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::TypeDefPb >&
GraphDefPb::type_defs() const {
  // @@protoc_insertion_point(field_list:gs.rpc.graph.GraphDefPb.type_defs)
  return _impl_.type_defs_;
}

// repeated .gs.rpc.graph.EdgeKindPb edge_kinds = 6;
inline int GraphDefPb::_internal_edge_kinds_size() const {
  return _impl_.edge_kinds_.size();
}
inline int GraphDefPb::edge_kinds_size() const {
  return _internal_edge_kinds_size();
}
inline ::gs::rpc::graph::EdgeKindPb* GraphDefPb::mutable_edge_kinds(int index) {
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.GraphDefPb.edge_kinds)
  return _impl_.edge_kinds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::EdgeKindPb >*
GraphDefPb::mutable_edge_kinds() {
  // @@protoc_insertion_point(field_mutable_list:gs.rpc.graph.GraphDefPb.edge_kinds)
  return &_impl_.edge_kinds_;
}
inline const ::gs::rpc::graph::EdgeKindPb& GraphDefPb::_internal_edge_kinds(int index) const {
  return _impl_.edge_kinds_.Get(index);
}
inline const ::gs::rpc::graph::EdgeKindPb& GraphDefPb::edge_kinds(int index) const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.edge_kinds)
  return _internal_edge_kinds(index);
}
inline ::gs::rpc::graph::EdgeKindPb* GraphDefPb::_internal_add_edge_kinds() {
  return _impl_.edge_kinds_.Add();
}
inline ::gs::rpc::graph::EdgeKindPb* GraphDefPb::add_edge_kinds() {
  ::gs::rpc::graph::EdgeKindPb* _add = _internal_add_edge_kinds();
  // @@protoc_insertion_point(field_add:gs.rpc.graph.GraphDefPb.edge_kinds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::EdgeKindPb >&
GraphDefPb::edge_kinds() const {
  // @@protoc_insertion_point(field_list:gs.rpc.graph.GraphDefPb.edge_kinds)
  return _impl_.edge_kinds_;
}

// map<string, int32> property_name_to_id = 7;
inline int GraphDefPb::_internal_property_name_to_id_size() const {
  return _impl_.property_name_to_id_.size();
}
inline int GraphDefPb::property_name_to_id_size() const {
  return _internal_property_name_to_id_size();
}
inline void GraphDefPb::clear_property_name_to_id() {
  _impl_.property_name_to_id_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
GraphDefPb::_internal_property_name_to_id() const {
  return _impl_.property_name_to_id_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
GraphDefPb::property_name_to_id() const {
  // @@protoc_insertion_point(field_map:gs.rpc.graph.GraphDefPb.property_name_to_id)
  return _internal_property_name_to_id();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
GraphDefPb::_internal_mutable_property_name_to_id() {
  return _impl_.property_name_to_id_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
GraphDefPb::mutable_property_name_to_id() {
  // @@protoc_insertion_point(field_mutable_map:gs.rpc.graph.GraphDefPb.property_name_to_id)
  return _internal_mutable_property_name_to_id();
}

// .google.protobuf.Any extension = 8;
inline bool GraphDefPb::_internal_has_extension() const {
  return this != internal_default_instance() && _impl_.extension_ != nullptr;
}
inline bool GraphDefPb::has_extension() const {
  return _internal_has_extension();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GraphDefPb::_internal_extension() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GraphDefPb::extension() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.extension)
  return _internal_extension();
}
inline void GraphDefPb::unsafe_arena_set_allocated_extension(
    ::PROTOBUF_NAMESPACE_ID::Any* extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_);
  }
  _impl_.extension_ = extension;
  if (extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gs.rpc.graph.GraphDefPb.extension)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GraphDefPb::release_extension() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.extension_;
  _impl_.extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GraphDefPb::unsafe_arena_release_extension() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.GraphDefPb.extension)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.extension_;
  _impl_.extension_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GraphDefPb::_internal_mutable_extension() {
  
  if (_impl_.extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.extension_ = p;
  }
  return _impl_.extension_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GraphDefPb::mutable_extension() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.GraphDefPb.extension)
  return _msg;
}
inline void GraphDefPb::set_allocated_extension(::PROTOBUF_NAMESPACE_ID::Any* extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_);
  }
  if (extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension));
    if (message_arena != submessage_arena) {
      extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extension_ = extension;
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.GraphDefPb.extension)
}

// bool is_multigraph = 9;
inline void GraphDefPb::clear_is_multigraph() {
  _impl_.is_multigraph_ = false;
}
inline bool GraphDefPb::_internal_is_multigraph() const {
  return _impl_.is_multigraph_;
}
inline bool GraphDefPb::is_multigraph() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.is_multigraph)
  return _internal_is_multigraph();
}
inline void GraphDefPb::_internal_set_is_multigraph(bool value) {
  
  _impl_.is_multigraph_ = value;
}
inline void GraphDefPb::set_is_multigraph(bool value) {
  _internal_set_is_multigraph(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GraphDefPb.is_multigraph)
}

// bool compact_edges = 10;
inline void GraphDefPb::clear_compact_edges() {
  _impl_.compact_edges_ = false;
}
inline bool GraphDefPb::_internal_compact_edges() const {
  return _impl_.compact_edges_;
}
inline bool GraphDefPb::compact_edges() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.compact_edges)
  return _internal_compact_edges();
}
inline void GraphDefPb::_internal_set_compact_edges(bool value) {
  
  _impl_.compact_edges_ = value;
}
inline void GraphDefPb::set_compact_edges(bool value) {
  _internal_set_compact_edges(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GraphDefPb.compact_edges)
}

// bool use_perfect_hash = 11;
inline void GraphDefPb::clear_use_perfect_hash() {
  _impl_.use_perfect_hash_ = false;
}
inline bool GraphDefPb::_internal_use_perfect_hash() const {
  return _impl_.use_perfect_hash_;
}
inline bool GraphDefPb::use_perfect_hash() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.GraphDefPb.use_perfect_hash)
  return _internal_use_perfect_hash();
}
inline void GraphDefPb::_internal_set_use_perfect_hash(bool value) {
  
  _impl_.use_perfect_hash_ = value;
}
inline void GraphDefPb::set_use_perfect_hash(bool value) {
  _internal_set_use_perfect_hash(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.GraphDefPb.use_perfect_hash)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace graph
}  // namespace rpc
}  // namespace gs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::gs::rpc::graph::GraphTypePb> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gs::rpc::graph::GraphTypePb>() {
  return ::gs::rpc::graph::GraphTypePb_descriptor();
}
template <> struct is_proto_enum< ::gs::rpc::graph::VertexMapTypePb> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gs::rpc::graph::VertexMapTypePb>() {
  return ::gs::rpc::graph::VertexMapTypePb_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_graph_5fdef_2eproto
