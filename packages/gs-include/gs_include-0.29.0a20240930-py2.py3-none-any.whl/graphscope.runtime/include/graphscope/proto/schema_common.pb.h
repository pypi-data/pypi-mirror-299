// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema_common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_schema_5fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_schema_5fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_schema_5fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_schema_5fcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_schema_5fcommon_2eproto;
namespace gs {
namespace rpc {
namespace graph {
class EdgeKindPb;
struct EdgeKindPbDefaultTypeInternal;
extern EdgeKindPbDefaultTypeInternal _EdgeKindPb_default_instance_;
class LabelIdPb;
struct LabelIdPbDefaultTypeInternal;
extern LabelIdPbDefaultTypeInternal _LabelIdPb_default_instance_;
class PropertyDefPb;
struct PropertyDefPbDefaultTypeInternal;
extern PropertyDefPbDefaultTypeInternal _PropertyDefPb_default_instance_;
class PropertyValuePb;
struct PropertyValuePbDefaultTypeInternal;
extern PropertyValuePbDefaultTypeInternal _PropertyValuePb_default_instance_;
class TypeDefPb;
struct TypeDefPbDefaultTypeInternal;
extern TypeDefPbDefaultTypeInternal _TypeDefPb_default_instance_;
}  // namespace graph
}  // namespace rpc
}  // namespace gs
PROTOBUF_NAMESPACE_OPEN
template<> ::gs::rpc::graph::EdgeKindPb* Arena::CreateMaybeMessage<::gs::rpc::graph::EdgeKindPb>(Arena*);
template<> ::gs::rpc::graph::LabelIdPb* Arena::CreateMaybeMessage<::gs::rpc::graph::LabelIdPb>(Arena*);
template<> ::gs::rpc::graph::PropertyDefPb* Arena::CreateMaybeMessage<::gs::rpc::graph::PropertyDefPb>(Arena*);
template<> ::gs::rpc::graph::PropertyValuePb* Arena::CreateMaybeMessage<::gs::rpc::graph::PropertyValuePb>(Arena*);
template<> ::gs::rpc::graph::TypeDefPb* Arena::CreateMaybeMessage<::gs::rpc::graph::TypeDefPb>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gs {
namespace rpc {
namespace graph {

enum TypeEnumPb : int {
  VERTEX = 0,
  EDGE = 1,
  TypeEnumPb_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TypeEnumPb_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TypeEnumPb_IsValid(int value);
constexpr TypeEnumPb TypeEnumPb_MIN = VERTEX;
constexpr TypeEnumPb TypeEnumPb_MAX = EDGE;
constexpr int TypeEnumPb_ARRAYSIZE = TypeEnumPb_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TypeEnumPb_descriptor();
template<typename T>
inline const std::string& TypeEnumPb_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TypeEnumPb>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TypeEnumPb_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TypeEnumPb_descriptor(), enum_t_value);
}
inline bool TypeEnumPb_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TypeEnumPb* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TypeEnumPb>(
    TypeEnumPb_descriptor(), name, value);
}
enum DataTypePb : int {
  UNKNOWN = 0,
  BOOL = 1,
  CHAR = 2,
  SHORT = 3,
  INT = 4,
  LONG = 5,
  FLOAT = 6,
  DOUBLE = 7,
  STRING = 8,
  BYTES = 9,
  INT_LIST = 10,
  LONG_LIST = 11,
  FLOAT_LIST = 12,
  DOUBLE_LIST = 13,
  STRING_LIST = 14,
  NULLVALUE = 15,
  UINT = 16,
  ULONG = 17,
  DYNAMIC = 18,
  DATE32 = 19,
  DATE64 = 20,
  TIME32_S = 21,
  TIME32_MS = 22,
  TIME32_US = 23,
  TIME32_NS = 24,
  TIME64_S = 25,
  TIME64_MS = 26,
  TIME64_US = 27,
  TIME64_NS = 28,
  TIMESTAMP_S = 29,
  TIMESTAMP_MS = 30,
  TIMESTAMP_US = 31,
  TIMESTAMP_NS = 32,
  DataTypePb_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataTypePb_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataTypePb_IsValid(int value);
constexpr DataTypePb DataTypePb_MIN = UNKNOWN;
constexpr DataTypePb DataTypePb_MAX = TIMESTAMP_NS;
constexpr int DataTypePb_ARRAYSIZE = DataTypePb_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataTypePb_descriptor();
template<typename T>
inline const std::string& DataTypePb_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataTypePb>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataTypePb_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataTypePb_descriptor(), enum_t_value);
}
inline bool DataTypePb_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataTypePb* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataTypePb>(
    DataTypePb_descriptor(), name, value);
}
// ===================================================================

class LabelIdPb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gs.rpc.graph.LabelIdPb) */ {
 public:
  inline LabelIdPb() : LabelIdPb(nullptr) {}
  ~LabelIdPb() override;
  explicit PROTOBUF_CONSTEXPR LabelIdPb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelIdPb(const LabelIdPb& from);
  LabelIdPb(LabelIdPb&& from) noexcept
    : LabelIdPb() {
    *this = ::std::move(from);
  }

  inline LabelIdPb& operator=(const LabelIdPb& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelIdPb& operator=(LabelIdPb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelIdPb& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelIdPb* internal_default_instance() {
    return reinterpret_cast<const LabelIdPb*>(
               &_LabelIdPb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LabelIdPb& a, LabelIdPb& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelIdPb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelIdPb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelIdPb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelIdPb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelIdPb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelIdPb& from) {
    LabelIdPb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelIdPb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gs.rpc.graph.LabelIdPb";
  }
  protected:
  explicit LabelIdPb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:gs.rpc.graph.LabelIdPb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class PropertyValuePb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gs.rpc.graph.PropertyValuePb) */ {
 public:
  inline PropertyValuePb() : PropertyValuePb(nullptr) {}
  ~PropertyValuePb() override;
  explicit PROTOBUF_CONSTEXPR PropertyValuePb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropertyValuePb(const PropertyValuePb& from);
  PropertyValuePb(PropertyValuePb&& from) noexcept
    : PropertyValuePb() {
    *this = ::std::move(from);
  }

  inline PropertyValuePb& operator=(const PropertyValuePb& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyValuePb& operator=(PropertyValuePb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropertyValuePb& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropertyValuePb* internal_default_instance() {
    return reinterpret_cast<const PropertyValuePb*>(
               &_PropertyValuePb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PropertyValuePb& a, PropertyValuePb& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyValuePb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropertyValuePb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropertyValuePb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropertyValuePb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropertyValuePb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropertyValuePb& from) {
    PropertyValuePb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropertyValuePb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gs.rpc.graph.PropertyValuePb";
  }
  protected:
  explicit PropertyValuePb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 2,
    kDataTypeFieldNumber = 1,
  };
  // bytes val = 2;
  void clear_val();
  const std::string& val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val();
  PROTOBUF_NODISCARD std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // .gs.rpc.graph.DataTypePb data_type = 1;
  void clear_data_type();
  ::gs::rpc::graph::DataTypePb data_type() const;
  void set_data_type(::gs::rpc::graph::DataTypePb value);
  private:
  ::gs::rpc::graph::DataTypePb _internal_data_type() const;
  void _internal_set_data_type(::gs::rpc::graph::DataTypePb value);
  public:

  // @@protoc_insertion_point(class_scope:gs.rpc.graph.PropertyValuePb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
    int data_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class EdgeKindPb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gs.rpc.graph.EdgeKindPb) */ {
 public:
  inline EdgeKindPb() : EdgeKindPb(nullptr) {}
  ~EdgeKindPb() override;
  explicit PROTOBUF_CONSTEXPR EdgeKindPb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgeKindPb(const EdgeKindPb& from);
  EdgeKindPb(EdgeKindPb&& from) noexcept
    : EdgeKindPb() {
    *this = ::std::move(from);
  }

  inline EdgeKindPb& operator=(const EdgeKindPb& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgeKindPb& operator=(EdgeKindPb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdgeKindPb& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdgeKindPb* internal_default_instance() {
    return reinterpret_cast<const EdgeKindPb*>(
               &_EdgeKindPb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EdgeKindPb& a, EdgeKindPb& b) {
    a.Swap(&b);
  }
  inline void Swap(EdgeKindPb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgeKindPb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdgeKindPb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdgeKindPb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EdgeKindPb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EdgeKindPb& from) {
    EdgeKindPb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeKindPb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gs.rpc.graph.EdgeKindPb";
  }
  protected:
  explicit EdgeKindPb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEdgeLabelFieldNumber = 1,
    kSrcVertexLabelFieldNumber = 3,
    kDstVertexLabelFieldNumber = 5,
    kEdgeLabelIdFieldNumber = 2,
    kSrcVertexLabelIdFieldNumber = 4,
    kDstVertexLabelIdFieldNumber = 6,
  };
  // string edge_label = 1;
  void clear_edge_label();
  const std::string& edge_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edge_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edge_label();
  PROTOBUF_NODISCARD std::string* release_edge_label();
  void set_allocated_edge_label(std::string* edge_label);
  private:
  const std::string& _internal_edge_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edge_label(const std::string& value);
  std::string* _internal_mutable_edge_label();
  public:

  // string src_vertex_label = 3;
  void clear_src_vertex_label();
  const std::string& src_vertex_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_vertex_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_vertex_label();
  PROTOBUF_NODISCARD std::string* release_src_vertex_label();
  void set_allocated_src_vertex_label(std::string* src_vertex_label);
  private:
  const std::string& _internal_src_vertex_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_vertex_label(const std::string& value);
  std::string* _internal_mutable_src_vertex_label();
  public:

  // string dst_vertex_label = 5;
  void clear_dst_vertex_label();
  const std::string& dst_vertex_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst_vertex_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst_vertex_label();
  PROTOBUF_NODISCARD std::string* release_dst_vertex_label();
  void set_allocated_dst_vertex_label(std::string* dst_vertex_label);
  private:
  const std::string& _internal_dst_vertex_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_vertex_label(const std::string& value);
  std::string* _internal_mutable_dst_vertex_label();
  public:

  // .gs.rpc.graph.LabelIdPb edge_label_id = 2;
  bool has_edge_label_id() const;
  private:
  bool _internal_has_edge_label_id() const;
  public:
  void clear_edge_label_id();
  const ::gs::rpc::graph::LabelIdPb& edge_label_id() const;
  PROTOBUF_NODISCARD ::gs::rpc::graph::LabelIdPb* release_edge_label_id();
  ::gs::rpc::graph::LabelIdPb* mutable_edge_label_id();
  void set_allocated_edge_label_id(::gs::rpc::graph::LabelIdPb* edge_label_id);
  private:
  const ::gs::rpc::graph::LabelIdPb& _internal_edge_label_id() const;
  ::gs::rpc::graph::LabelIdPb* _internal_mutable_edge_label_id();
  public:
  void unsafe_arena_set_allocated_edge_label_id(
      ::gs::rpc::graph::LabelIdPb* edge_label_id);
  ::gs::rpc::graph::LabelIdPb* unsafe_arena_release_edge_label_id();

  // .gs.rpc.graph.LabelIdPb src_vertex_label_id = 4;
  bool has_src_vertex_label_id() const;
  private:
  bool _internal_has_src_vertex_label_id() const;
  public:
  void clear_src_vertex_label_id();
  const ::gs::rpc::graph::LabelIdPb& src_vertex_label_id() const;
  PROTOBUF_NODISCARD ::gs::rpc::graph::LabelIdPb* release_src_vertex_label_id();
  ::gs::rpc::graph::LabelIdPb* mutable_src_vertex_label_id();
  void set_allocated_src_vertex_label_id(::gs::rpc::graph::LabelIdPb* src_vertex_label_id);
  private:
  const ::gs::rpc::graph::LabelIdPb& _internal_src_vertex_label_id() const;
  ::gs::rpc::graph::LabelIdPb* _internal_mutable_src_vertex_label_id();
  public:
  void unsafe_arena_set_allocated_src_vertex_label_id(
      ::gs::rpc::graph::LabelIdPb* src_vertex_label_id);
  ::gs::rpc::graph::LabelIdPb* unsafe_arena_release_src_vertex_label_id();

  // .gs.rpc.graph.LabelIdPb dst_vertex_label_id = 6;
  bool has_dst_vertex_label_id() const;
  private:
  bool _internal_has_dst_vertex_label_id() const;
  public:
  void clear_dst_vertex_label_id();
  const ::gs::rpc::graph::LabelIdPb& dst_vertex_label_id() const;
  PROTOBUF_NODISCARD ::gs::rpc::graph::LabelIdPb* release_dst_vertex_label_id();
  ::gs::rpc::graph::LabelIdPb* mutable_dst_vertex_label_id();
  void set_allocated_dst_vertex_label_id(::gs::rpc::graph::LabelIdPb* dst_vertex_label_id);
  private:
  const ::gs::rpc::graph::LabelIdPb& _internal_dst_vertex_label_id() const;
  ::gs::rpc::graph::LabelIdPb* _internal_mutable_dst_vertex_label_id();
  public:
  void unsafe_arena_set_allocated_dst_vertex_label_id(
      ::gs::rpc::graph::LabelIdPb* dst_vertex_label_id);
  ::gs::rpc::graph::LabelIdPb* unsafe_arena_release_dst_vertex_label_id();

  // @@protoc_insertion_point(class_scope:gs.rpc.graph.EdgeKindPb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edge_label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_vertex_label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_vertex_label_;
    ::gs::rpc::graph::LabelIdPb* edge_label_id_;
    ::gs::rpc::graph::LabelIdPb* src_vertex_label_id_;
    ::gs::rpc::graph::LabelIdPb* dst_vertex_label_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class PropertyDefPb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gs.rpc.graph.PropertyDefPb) */ {
 public:
  inline PropertyDefPb() : PropertyDefPb(nullptr) {}
  ~PropertyDefPb() override;
  explicit PROTOBUF_CONSTEXPR PropertyDefPb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropertyDefPb(const PropertyDefPb& from);
  PropertyDefPb(PropertyDefPb&& from) noexcept
    : PropertyDefPb() {
    *this = ::std::move(from);
  }

  inline PropertyDefPb& operator=(const PropertyDefPb& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyDefPb& operator=(PropertyDefPb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropertyDefPb& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropertyDefPb* internal_default_instance() {
    return reinterpret_cast<const PropertyDefPb*>(
               &_PropertyDefPb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PropertyDefPb& a, PropertyDefPb& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyDefPb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropertyDefPb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropertyDefPb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropertyDefPb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropertyDefPb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropertyDefPb& from) {
    PropertyDefPb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropertyDefPb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gs.rpc.graph.PropertyDefPb";
  }
  protected:
  explicit PropertyDefPb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kCommentFieldNumber = 7,
    kDefaultValueFieldNumber = 5,
    kIdFieldNumber = 1,
    kInnerIdFieldNumber = 2,
    kDataTypeFieldNumber = 4,
    kPkFieldNumber = 6,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string comment = 7;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .gs.rpc.graph.PropertyValuePb default_value = 5;
  bool has_default_value() const;
  private:
  bool _internal_has_default_value() const;
  public:
  void clear_default_value();
  const ::gs::rpc::graph::PropertyValuePb& default_value() const;
  PROTOBUF_NODISCARD ::gs::rpc::graph::PropertyValuePb* release_default_value();
  ::gs::rpc::graph::PropertyValuePb* mutable_default_value();
  void set_allocated_default_value(::gs::rpc::graph::PropertyValuePb* default_value);
  private:
  const ::gs::rpc::graph::PropertyValuePb& _internal_default_value() const;
  ::gs::rpc::graph::PropertyValuePb* _internal_mutable_default_value();
  public:
  void unsafe_arena_set_allocated_default_value(
      ::gs::rpc::graph::PropertyValuePb* default_value);
  ::gs::rpc::graph::PropertyValuePb* unsafe_arena_release_default_value();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 inner_id = 2;
  void clear_inner_id();
  int32_t inner_id() const;
  void set_inner_id(int32_t value);
  private:
  int32_t _internal_inner_id() const;
  void _internal_set_inner_id(int32_t value);
  public:

  // .gs.rpc.graph.DataTypePb data_type = 4;
  void clear_data_type();
  ::gs::rpc::graph::DataTypePb data_type() const;
  void set_data_type(::gs::rpc::graph::DataTypePb value);
  private:
  ::gs::rpc::graph::DataTypePb _internal_data_type() const;
  void _internal_set_data_type(::gs::rpc::graph::DataTypePb value);
  public:

  // bool pk = 6;
  void clear_pk();
  bool pk() const;
  void set_pk(bool value);
  private:
  bool _internal_pk() const;
  void _internal_set_pk(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gs.rpc.graph.PropertyDefPb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::gs::rpc::graph::PropertyValuePb* default_value_;
    int32_t id_;
    int32_t inner_id_;
    int data_type_;
    bool pk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class TypeDefPb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gs.rpc.graph.TypeDefPb) */ {
 public:
  inline TypeDefPb() : TypeDefPb(nullptr) {}
  ~TypeDefPb() override;
  explicit PROTOBUF_CONSTEXPR TypeDefPb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeDefPb(const TypeDefPb& from);
  TypeDefPb(TypeDefPb&& from) noexcept
    : TypeDefPb() {
    *this = ::std::move(from);
  }

  inline TypeDefPb& operator=(const TypeDefPb& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeDefPb& operator=(TypeDefPb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeDefPb& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeDefPb* internal_default_instance() {
    return reinterpret_cast<const TypeDefPb*>(
               &_TypeDefPb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TypeDefPb& a, TypeDefPb& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeDefPb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeDefPb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeDefPb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeDefPb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypeDefPb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypeDefPb& from) {
    TypeDefPb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeDefPb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gs.rpc.graph.TypeDefPb";
  }
  protected:
  explicit TypeDefPb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropsFieldNumber = 5,
    kLabelFieldNumber = 2,
    kCommentFieldNumber = 6,
    kLabelIdFieldNumber = 3,
    kVersionIdFieldNumber = 1,
    kTypeEnumFieldNumber = 4,
  };
  // repeated .gs.rpc.graph.PropertyDefPb props = 5;
  int props_size() const;
  private:
  int _internal_props_size() const;
  public:
  void clear_props();
  ::gs::rpc::graph::PropertyDefPb* mutable_props(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::PropertyDefPb >*
      mutable_props();
  private:
  const ::gs::rpc::graph::PropertyDefPb& _internal_props(int index) const;
  ::gs::rpc::graph::PropertyDefPb* _internal_add_props();
  public:
  const ::gs::rpc::graph::PropertyDefPb& props(int index) const;
  ::gs::rpc::graph::PropertyDefPb* add_props();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::PropertyDefPb >&
      props() const;

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // string comment = 6;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .gs.rpc.graph.LabelIdPb label_id = 3;
  bool has_label_id() const;
  private:
  bool _internal_has_label_id() const;
  public:
  void clear_label_id();
  const ::gs::rpc::graph::LabelIdPb& label_id() const;
  PROTOBUF_NODISCARD ::gs::rpc::graph::LabelIdPb* release_label_id();
  ::gs::rpc::graph::LabelIdPb* mutable_label_id();
  void set_allocated_label_id(::gs::rpc::graph::LabelIdPb* label_id);
  private:
  const ::gs::rpc::graph::LabelIdPb& _internal_label_id() const;
  ::gs::rpc::graph::LabelIdPb* _internal_mutable_label_id();
  public:
  void unsafe_arena_set_allocated_label_id(
      ::gs::rpc::graph::LabelIdPb* label_id);
  ::gs::rpc::graph::LabelIdPb* unsafe_arena_release_label_id();

  // int32 version_id = 1;
  void clear_version_id();
  int32_t version_id() const;
  void set_version_id(int32_t value);
  private:
  int32_t _internal_version_id() const;
  void _internal_set_version_id(int32_t value);
  public:

  // .gs.rpc.graph.TypeEnumPb type_enum = 4;
  void clear_type_enum();
  ::gs::rpc::graph::TypeEnumPb type_enum() const;
  void set_type_enum(::gs::rpc::graph::TypeEnumPb value);
  private:
  ::gs::rpc::graph::TypeEnumPb _internal_type_enum() const;
  void _internal_set_type_enum(::gs::rpc::graph::TypeEnumPb value);
  public:

  // @@protoc_insertion_point(class_scope:gs.rpc.graph.TypeDefPb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::PropertyDefPb > props_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::gs::rpc::graph::LabelIdPb* label_id_;
    int32_t version_id_;
    int type_enum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_5fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LabelIdPb

// int32 id = 1;
inline void LabelIdPb::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t LabelIdPb::_internal_id() const {
  return _impl_.id_;
}
inline int32_t LabelIdPb::id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.LabelIdPb.id)
  return _internal_id();
}
inline void LabelIdPb::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void LabelIdPb::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.LabelIdPb.id)
}

// -------------------------------------------------------------------

// PropertyValuePb

// .gs.rpc.graph.DataTypePb data_type = 1;
inline void PropertyValuePb::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::gs::rpc::graph::DataTypePb PropertyValuePb::_internal_data_type() const {
  return static_cast< ::gs::rpc::graph::DataTypePb >(_impl_.data_type_);
}
inline ::gs::rpc::graph::DataTypePb PropertyValuePb::data_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.PropertyValuePb.data_type)
  return _internal_data_type();
}
inline void PropertyValuePb::_internal_set_data_type(::gs::rpc::graph::DataTypePb value) {
  
  _impl_.data_type_ = value;
}
inline void PropertyValuePb::set_data_type(::gs::rpc::graph::DataTypePb value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.PropertyValuePb.data_type)
}

// bytes val = 2;
inline void PropertyValuePb::clear_val() {
  _impl_.val_.ClearToEmpty();
}
inline const std::string& PropertyValuePb::val() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.PropertyValuePb.val)
  return _internal_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PropertyValuePb::set_val(ArgT0&& arg0, ArgT... args) {
 
 _impl_.val_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.PropertyValuePb.val)
}
inline std::string* PropertyValuePb::mutable_val() {
  std::string* _s = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.PropertyValuePb.val)
  return _s;
}
inline const std::string& PropertyValuePb::_internal_val() const {
  return _impl_.val_.Get();
}
inline void PropertyValuePb::_internal_set_val(const std::string& value) {
  
  _impl_.val_.Set(value, GetArenaForAllocation());
}
inline std::string* PropertyValuePb::_internal_mutable_val() {
  
  return _impl_.val_.Mutable(GetArenaForAllocation());
}
inline std::string* PropertyValuePb::release_val() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.PropertyValuePb.val)
  return _impl_.val_.Release();
}
inline void PropertyValuePb::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    
  } else {
    
  }
  _impl_.val_.SetAllocated(val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.PropertyValuePb.val)
}

// -------------------------------------------------------------------

// EdgeKindPb

// string edge_label = 1;
inline void EdgeKindPb::clear_edge_label() {
  _impl_.edge_label_.ClearToEmpty();
}
inline const std::string& EdgeKindPb::edge_label() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.EdgeKindPb.edge_label)
  return _internal_edge_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdgeKindPb::set_edge_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.edge_label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.EdgeKindPb.edge_label)
}
inline std::string* EdgeKindPb::mutable_edge_label() {
  std::string* _s = _internal_mutable_edge_label();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.EdgeKindPb.edge_label)
  return _s;
}
inline const std::string& EdgeKindPb::_internal_edge_label() const {
  return _impl_.edge_label_.Get();
}
inline void EdgeKindPb::_internal_set_edge_label(const std::string& value) {
  
  _impl_.edge_label_.Set(value, GetArenaForAllocation());
}
inline std::string* EdgeKindPb::_internal_mutable_edge_label() {
  
  return _impl_.edge_label_.Mutable(GetArenaForAllocation());
}
inline std::string* EdgeKindPb::release_edge_label() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.EdgeKindPb.edge_label)
  return _impl_.edge_label_.Release();
}
inline void EdgeKindPb::set_allocated_edge_label(std::string* edge_label) {
  if (edge_label != nullptr) {
    
  } else {
    
  }
  _impl_.edge_label_.SetAllocated(edge_label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.edge_label_.IsDefault()) {
    _impl_.edge_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.EdgeKindPb.edge_label)
}

// .gs.rpc.graph.LabelIdPb edge_label_id = 2;
inline bool EdgeKindPb::_internal_has_edge_label_id() const {
  return this != internal_default_instance() && _impl_.edge_label_id_ != nullptr;
}
inline bool EdgeKindPb::has_edge_label_id() const {
  return _internal_has_edge_label_id();
}
inline void EdgeKindPb::clear_edge_label_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.edge_label_id_ != nullptr) {
    delete _impl_.edge_label_id_;
  }
  _impl_.edge_label_id_ = nullptr;
}
inline const ::gs::rpc::graph::LabelIdPb& EdgeKindPb::_internal_edge_label_id() const {
  const ::gs::rpc::graph::LabelIdPb* p = _impl_.edge_label_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::gs::rpc::graph::LabelIdPb&>(
      ::gs::rpc::graph::_LabelIdPb_default_instance_);
}
inline const ::gs::rpc::graph::LabelIdPb& EdgeKindPb::edge_label_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.EdgeKindPb.edge_label_id)
  return _internal_edge_label_id();
}
inline void EdgeKindPb::unsafe_arena_set_allocated_edge_label_id(
    ::gs::rpc::graph::LabelIdPb* edge_label_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.edge_label_id_);
  }
  _impl_.edge_label_id_ = edge_label_id;
  if (edge_label_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gs.rpc.graph.EdgeKindPb.edge_label_id)
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::release_edge_label_id() {
  
  ::gs::rpc::graph::LabelIdPb* temp = _impl_.edge_label_id_;
  _impl_.edge_label_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::unsafe_arena_release_edge_label_id() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.EdgeKindPb.edge_label_id)
  
  ::gs::rpc::graph::LabelIdPb* temp = _impl_.edge_label_id_;
  _impl_.edge_label_id_ = nullptr;
  return temp;
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::_internal_mutable_edge_label_id() {
  
  if (_impl_.edge_label_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::gs::rpc::graph::LabelIdPb>(GetArenaForAllocation());
    _impl_.edge_label_id_ = p;
  }
  return _impl_.edge_label_id_;
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::mutable_edge_label_id() {
  ::gs::rpc::graph::LabelIdPb* _msg = _internal_mutable_edge_label_id();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.EdgeKindPb.edge_label_id)
  return _msg;
}
inline void EdgeKindPb::set_allocated_edge_label_id(::gs::rpc::graph::LabelIdPb* edge_label_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.edge_label_id_;
  }
  if (edge_label_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edge_label_id);
    if (message_arena != submessage_arena) {
      edge_label_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge_label_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.edge_label_id_ = edge_label_id;
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.EdgeKindPb.edge_label_id)
}

// string src_vertex_label = 3;
inline void EdgeKindPb::clear_src_vertex_label() {
  _impl_.src_vertex_label_.ClearToEmpty();
}
inline const std::string& EdgeKindPb::src_vertex_label() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.EdgeKindPb.src_vertex_label)
  return _internal_src_vertex_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdgeKindPb::set_src_vertex_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_vertex_label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.EdgeKindPb.src_vertex_label)
}
inline std::string* EdgeKindPb::mutable_src_vertex_label() {
  std::string* _s = _internal_mutable_src_vertex_label();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.EdgeKindPb.src_vertex_label)
  return _s;
}
inline const std::string& EdgeKindPb::_internal_src_vertex_label() const {
  return _impl_.src_vertex_label_.Get();
}
inline void EdgeKindPb::_internal_set_src_vertex_label(const std::string& value) {
  
  _impl_.src_vertex_label_.Set(value, GetArenaForAllocation());
}
inline std::string* EdgeKindPb::_internal_mutable_src_vertex_label() {
  
  return _impl_.src_vertex_label_.Mutable(GetArenaForAllocation());
}
inline std::string* EdgeKindPb::release_src_vertex_label() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.EdgeKindPb.src_vertex_label)
  return _impl_.src_vertex_label_.Release();
}
inline void EdgeKindPb::set_allocated_src_vertex_label(std::string* src_vertex_label) {
  if (src_vertex_label != nullptr) {
    
  } else {
    
  }
  _impl_.src_vertex_label_.SetAllocated(src_vertex_label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_vertex_label_.IsDefault()) {
    _impl_.src_vertex_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.EdgeKindPb.src_vertex_label)
}

// .gs.rpc.graph.LabelIdPb src_vertex_label_id = 4;
inline bool EdgeKindPb::_internal_has_src_vertex_label_id() const {
  return this != internal_default_instance() && _impl_.src_vertex_label_id_ != nullptr;
}
inline bool EdgeKindPb::has_src_vertex_label_id() const {
  return _internal_has_src_vertex_label_id();
}
inline void EdgeKindPb::clear_src_vertex_label_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.src_vertex_label_id_ != nullptr) {
    delete _impl_.src_vertex_label_id_;
  }
  _impl_.src_vertex_label_id_ = nullptr;
}
inline const ::gs::rpc::graph::LabelIdPb& EdgeKindPb::_internal_src_vertex_label_id() const {
  const ::gs::rpc::graph::LabelIdPb* p = _impl_.src_vertex_label_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::gs::rpc::graph::LabelIdPb&>(
      ::gs::rpc::graph::_LabelIdPb_default_instance_);
}
inline const ::gs::rpc::graph::LabelIdPb& EdgeKindPb::src_vertex_label_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.EdgeKindPb.src_vertex_label_id)
  return _internal_src_vertex_label_id();
}
inline void EdgeKindPb::unsafe_arena_set_allocated_src_vertex_label_id(
    ::gs::rpc::graph::LabelIdPb* src_vertex_label_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_vertex_label_id_);
  }
  _impl_.src_vertex_label_id_ = src_vertex_label_id;
  if (src_vertex_label_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gs.rpc.graph.EdgeKindPb.src_vertex_label_id)
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::release_src_vertex_label_id() {
  
  ::gs::rpc::graph::LabelIdPb* temp = _impl_.src_vertex_label_id_;
  _impl_.src_vertex_label_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::unsafe_arena_release_src_vertex_label_id() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.EdgeKindPb.src_vertex_label_id)
  
  ::gs::rpc::graph::LabelIdPb* temp = _impl_.src_vertex_label_id_;
  _impl_.src_vertex_label_id_ = nullptr;
  return temp;
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::_internal_mutable_src_vertex_label_id() {
  
  if (_impl_.src_vertex_label_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::gs::rpc::graph::LabelIdPb>(GetArenaForAllocation());
    _impl_.src_vertex_label_id_ = p;
  }
  return _impl_.src_vertex_label_id_;
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::mutable_src_vertex_label_id() {
  ::gs::rpc::graph::LabelIdPb* _msg = _internal_mutable_src_vertex_label_id();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.EdgeKindPb.src_vertex_label_id)
  return _msg;
}
inline void EdgeKindPb::set_allocated_src_vertex_label_id(::gs::rpc::graph::LabelIdPb* src_vertex_label_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.src_vertex_label_id_;
  }
  if (src_vertex_label_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(src_vertex_label_id);
    if (message_arena != submessage_arena) {
      src_vertex_label_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src_vertex_label_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.src_vertex_label_id_ = src_vertex_label_id;
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.EdgeKindPb.src_vertex_label_id)
}

// string dst_vertex_label = 5;
inline void EdgeKindPb::clear_dst_vertex_label() {
  _impl_.dst_vertex_label_.ClearToEmpty();
}
inline const std::string& EdgeKindPb::dst_vertex_label() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.EdgeKindPb.dst_vertex_label)
  return _internal_dst_vertex_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdgeKindPb::set_dst_vertex_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dst_vertex_label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.EdgeKindPb.dst_vertex_label)
}
inline std::string* EdgeKindPb::mutable_dst_vertex_label() {
  std::string* _s = _internal_mutable_dst_vertex_label();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.EdgeKindPb.dst_vertex_label)
  return _s;
}
inline const std::string& EdgeKindPb::_internal_dst_vertex_label() const {
  return _impl_.dst_vertex_label_.Get();
}
inline void EdgeKindPb::_internal_set_dst_vertex_label(const std::string& value) {
  
  _impl_.dst_vertex_label_.Set(value, GetArenaForAllocation());
}
inline std::string* EdgeKindPb::_internal_mutable_dst_vertex_label() {
  
  return _impl_.dst_vertex_label_.Mutable(GetArenaForAllocation());
}
inline std::string* EdgeKindPb::release_dst_vertex_label() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.EdgeKindPb.dst_vertex_label)
  return _impl_.dst_vertex_label_.Release();
}
inline void EdgeKindPb::set_allocated_dst_vertex_label(std::string* dst_vertex_label) {
  if (dst_vertex_label != nullptr) {
    
  } else {
    
  }
  _impl_.dst_vertex_label_.SetAllocated(dst_vertex_label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_vertex_label_.IsDefault()) {
    _impl_.dst_vertex_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.EdgeKindPb.dst_vertex_label)
}

// .gs.rpc.graph.LabelIdPb dst_vertex_label_id = 6;
inline bool EdgeKindPb::_internal_has_dst_vertex_label_id() const {
  return this != internal_default_instance() && _impl_.dst_vertex_label_id_ != nullptr;
}
inline bool EdgeKindPb::has_dst_vertex_label_id() const {
  return _internal_has_dst_vertex_label_id();
}
inline void EdgeKindPb::clear_dst_vertex_label_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.dst_vertex_label_id_ != nullptr) {
    delete _impl_.dst_vertex_label_id_;
  }
  _impl_.dst_vertex_label_id_ = nullptr;
}
inline const ::gs::rpc::graph::LabelIdPb& EdgeKindPb::_internal_dst_vertex_label_id() const {
  const ::gs::rpc::graph::LabelIdPb* p = _impl_.dst_vertex_label_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::gs::rpc::graph::LabelIdPb&>(
      ::gs::rpc::graph::_LabelIdPb_default_instance_);
}
inline const ::gs::rpc::graph::LabelIdPb& EdgeKindPb::dst_vertex_label_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.EdgeKindPb.dst_vertex_label_id)
  return _internal_dst_vertex_label_id();
}
inline void EdgeKindPb::unsafe_arena_set_allocated_dst_vertex_label_id(
    ::gs::rpc::graph::LabelIdPb* dst_vertex_label_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dst_vertex_label_id_);
  }
  _impl_.dst_vertex_label_id_ = dst_vertex_label_id;
  if (dst_vertex_label_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gs.rpc.graph.EdgeKindPb.dst_vertex_label_id)
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::release_dst_vertex_label_id() {
  
  ::gs::rpc::graph::LabelIdPb* temp = _impl_.dst_vertex_label_id_;
  _impl_.dst_vertex_label_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::unsafe_arena_release_dst_vertex_label_id() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.EdgeKindPb.dst_vertex_label_id)
  
  ::gs::rpc::graph::LabelIdPb* temp = _impl_.dst_vertex_label_id_;
  _impl_.dst_vertex_label_id_ = nullptr;
  return temp;
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::_internal_mutable_dst_vertex_label_id() {
  
  if (_impl_.dst_vertex_label_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::gs::rpc::graph::LabelIdPb>(GetArenaForAllocation());
    _impl_.dst_vertex_label_id_ = p;
  }
  return _impl_.dst_vertex_label_id_;
}
inline ::gs::rpc::graph::LabelIdPb* EdgeKindPb::mutable_dst_vertex_label_id() {
  ::gs::rpc::graph::LabelIdPb* _msg = _internal_mutable_dst_vertex_label_id();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.EdgeKindPb.dst_vertex_label_id)
  return _msg;
}
inline void EdgeKindPb::set_allocated_dst_vertex_label_id(::gs::rpc::graph::LabelIdPb* dst_vertex_label_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dst_vertex_label_id_;
  }
  if (dst_vertex_label_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dst_vertex_label_id);
    if (message_arena != submessage_arena) {
      dst_vertex_label_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst_vertex_label_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dst_vertex_label_id_ = dst_vertex_label_id;
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.EdgeKindPb.dst_vertex_label_id)
}

// -------------------------------------------------------------------

// PropertyDefPb

// int32 id = 1;
inline void PropertyDefPb::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t PropertyDefPb::_internal_id() const {
  return _impl_.id_;
}
inline int32_t PropertyDefPb::id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.PropertyDefPb.id)
  return _internal_id();
}
inline void PropertyDefPb::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void PropertyDefPb::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.PropertyDefPb.id)
}

// int32 inner_id = 2;
inline void PropertyDefPb::clear_inner_id() {
  _impl_.inner_id_ = 0;
}
inline int32_t PropertyDefPb::_internal_inner_id() const {
  return _impl_.inner_id_;
}
inline int32_t PropertyDefPb::inner_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.PropertyDefPb.inner_id)
  return _internal_inner_id();
}
inline void PropertyDefPb::_internal_set_inner_id(int32_t value) {
  
  _impl_.inner_id_ = value;
}
inline void PropertyDefPb::set_inner_id(int32_t value) {
  _internal_set_inner_id(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.PropertyDefPb.inner_id)
}

// string name = 3;
inline void PropertyDefPb::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PropertyDefPb::name() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.PropertyDefPb.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PropertyDefPb::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.PropertyDefPb.name)
}
inline std::string* PropertyDefPb::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.PropertyDefPb.name)
  return _s;
}
inline const std::string& PropertyDefPb::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PropertyDefPb::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PropertyDefPb::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PropertyDefPb::release_name() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.PropertyDefPb.name)
  return _impl_.name_.Release();
}
inline void PropertyDefPb::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.PropertyDefPb.name)
}

// .gs.rpc.graph.DataTypePb data_type = 4;
inline void PropertyDefPb::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::gs::rpc::graph::DataTypePb PropertyDefPb::_internal_data_type() const {
  return static_cast< ::gs::rpc::graph::DataTypePb >(_impl_.data_type_);
}
inline ::gs::rpc::graph::DataTypePb PropertyDefPb::data_type() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.PropertyDefPb.data_type)
  return _internal_data_type();
}
inline void PropertyDefPb::_internal_set_data_type(::gs::rpc::graph::DataTypePb value) {
  
  _impl_.data_type_ = value;
}
inline void PropertyDefPb::set_data_type(::gs::rpc::graph::DataTypePb value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.PropertyDefPb.data_type)
}

// .gs.rpc.graph.PropertyValuePb default_value = 5;
inline bool PropertyDefPb::_internal_has_default_value() const {
  return this != internal_default_instance() && _impl_.default_value_ != nullptr;
}
inline bool PropertyDefPb::has_default_value() const {
  return _internal_has_default_value();
}
inline void PropertyDefPb::clear_default_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.default_value_ != nullptr) {
    delete _impl_.default_value_;
  }
  _impl_.default_value_ = nullptr;
}
inline const ::gs::rpc::graph::PropertyValuePb& PropertyDefPb::_internal_default_value() const {
  const ::gs::rpc::graph::PropertyValuePb* p = _impl_.default_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::gs::rpc::graph::PropertyValuePb&>(
      ::gs::rpc::graph::_PropertyValuePb_default_instance_);
}
inline const ::gs::rpc::graph::PropertyValuePb& PropertyDefPb::default_value() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.PropertyDefPb.default_value)
  return _internal_default_value();
}
inline void PropertyDefPb::unsafe_arena_set_allocated_default_value(
    ::gs::rpc::graph::PropertyValuePb* default_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_value_);
  }
  _impl_.default_value_ = default_value;
  if (default_value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gs.rpc.graph.PropertyDefPb.default_value)
}
inline ::gs::rpc::graph::PropertyValuePb* PropertyDefPb::release_default_value() {
  
  ::gs::rpc::graph::PropertyValuePb* temp = _impl_.default_value_;
  _impl_.default_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gs::rpc::graph::PropertyValuePb* PropertyDefPb::unsafe_arena_release_default_value() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.PropertyDefPb.default_value)
  
  ::gs::rpc::graph::PropertyValuePb* temp = _impl_.default_value_;
  _impl_.default_value_ = nullptr;
  return temp;
}
inline ::gs::rpc::graph::PropertyValuePb* PropertyDefPb::_internal_mutable_default_value() {
  
  if (_impl_.default_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::gs::rpc::graph::PropertyValuePb>(GetArenaForAllocation());
    _impl_.default_value_ = p;
  }
  return _impl_.default_value_;
}
inline ::gs::rpc::graph::PropertyValuePb* PropertyDefPb::mutable_default_value() {
  ::gs::rpc::graph::PropertyValuePb* _msg = _internal_mutable_default_value();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.PropertyDefPb.default_value)
  return _msg;
}
inline void PropertyDefPb::set_allocated_default_value(::gs::rpc::graph::PropertyValuePb* default_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default_value_;
  }
  if (default_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_value);
    if (message_arena != submessage_arena) {
      default_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default_value_ = default_value;
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.PropertyDefPb.default_value)
}

// bool pk = 6;
inline void PropertyDefPb::clear_pk() {
  _impl_.pk_ = false;
}
inline bool PropertyDefPb::_internal_pk() const {
  return _impl_.pk_;
}
inline bool PropertyDefPb::pk() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.PropertyDefPb.pk)
  return _internal_pk();
}
inline void PropertyDefPb::_internal_set_pk(bool value) {
  
  _impl_.pk_ = value;
}
inline void PropertyDefPb::set_pk(bool value) {
  _internal_set_pk(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.PropertyDefPb.pk)
}

// string comment = 7;
inline void PropertyDefPb::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& PropertyDefPb::comment() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.PropertyDefPb.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PropertyDefPb::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.PropertyDefPb.comment)
}
inline std::string* PropertyDefPb::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.PropertyDefPb.comment)
  return _s;
}
inline const std::string& PropertyDefPb::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void PropertyDefPb::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* PropertyDefPb::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* PropertyDefPb::release_comment() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.PropertyDefPb.comment)
  return _impl_.comment_.Release();
}
inline void PropertyDefPb::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.PropertyDefPb.comment)
}

// -------------------------------------------------------------------

// TypeDefPb

// int32 version_id = 1;
inline void TypeDefPb::clear_version_id() {
  _impl_.version_id_ = 0;
}
inline int32_t TypeDefPb::_internal_version_id() const {
  return _impl_.version_id_;
}
inline int32_t TypeDefPb::version_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.TypeDefPb.version_id)
  return _internal_version_id();
}
inline void TypeDefPb::_internal_set_version_id(int32_t value) {
  
  _impl_.version_id_ = value;
}
inline void TypeDefPb::set_version_id(int32_t value) {
  _internal_set_version_id(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.TypeDefPb.version_id)
}

// string label = 2;
inline void TypeDefPb::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& TypeDefPb::label() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.TypeDefPb.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypeDefPb::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.TypeDefPb.label)
}
inline std::string* TypeDefPb::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.TypeDefPb.label)
  return _s;
}
inline const std::string& TypeDefPb::_internal_label() const {
  return _impl_.label_.Get();
}
inline void TypeDefPb::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* TypeDefPb::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* TypeDefPb::release_label() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.TypeDefPb.label)
  return _impl_.label_.Release();
}
inline void TypeDefPb::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.TypeDefPb.label)
}

// .gs.rpc.graph.LabelIdPb label_id = 3;
inline bool TypeDefPb::_internal_has_label_id() const {
  return this != internal_default_instance() && _impl_.label_id_ != nullptr;
}
inline bool TypeDefPb::has_label_id() const {
  return _internal_has_label_id();
}
inline void TypeDefPb::clear_label_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.label_id_ != nullptr) {
    delete _impl_.label_id_;
  }
  _impl_.label_id_ = nullptr;
}
inline const ::gs::rpc::graph::LabelIdPb& TypeDefPb::_internal_label_id() const {
  const ::gs::rpc::graph::LabelIdPb* p = _impl_.label_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::gs::rpc::graph::LabelIdPb&>(
      ::gs::rpc::graph::_LabelIdPb_default_instance_);
}
inline const ::gs::rpc::graph::LabelIdPb& TypeDefPb::label_id() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.TypeDefPb.label_id)
  return _internal_label_id();
}
inline void TypeDefPb::unsafe_arena_set_allocated_label_id(
    ::gs::rpc::graph::LabelIdPb* label_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.label_id_);
  }
  _impl_.label_id_ = label_id;
  if (label_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gs.rpc.graph.TypeDefPb.label_id)
}
inline ::gs::rpc::graph::LabelIdPb* TypeDefPb::release_label_id() {
  
  ::gs::rpc::graph::LabelIdPb* temp = _impl_.label_id_;
  _impl_.label_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gs::rpc::graph::LabelIdPb* TypeDefPb::unsafe_arena_release_label_id() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.TypeDefPb.label_id)
  
  ::gs::rpc::graph::LabelIdPb* temp = _impl_.label_id_;
  _impl_.label_id_ = nullptr;
  return temp;
}
inline ::gs::rpc::graph::LabelIdPb* TypeDefPb::_internal_mutable_label_id() {
  
  if (_impl_.label_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::gs::rpc::graph::LabelIdPb>(GetArenaForAllocation());
    _impl_.label_id_ = p;
  }
  return _impl_.label_id_;
}
inline ::gs::rpc::graph::LabelIdPb* TypeDefPb::mutable_label_id() {
  ::gs::rpc::graph::LabelIdPb* _msg = _internal_mutable_label_id();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.TypeDefPb.label_id)
  return _msg;
}
inline void TypeDefPb::set_allocated_label_id(::gs::rpc::graph::LabelIdPb* label_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.label_id_;
  }
  if (label_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(label_id);
    if (message_arena != submessage_arena) {
      label_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, label_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.label_id_ = label_id;
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.TypeDefPb.label_id)
}

// .gs.rpc.graph.TypeEnumPb type_enum = 4;
inline void TypeDefPb::clear_type_enum() {
  _impl_.type_enum_ = 0;
}
inline ::gs::rpc::graph::TypeEnumPb TypeDefPb::_internal_type_enum() const {
  return static_cast< ::gs::rpc::graph::TypeEnumPb >(_impl_.type_enum_);
}
inline ::gs::rpc::graph::TypeEnumPb TypeDefPb::type_enum() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.TypeDefPb.type_enum)
  return _internal_type_enum();
}
inline void TypeDefPb::_internal_set_type_enum(::gs::rpc::graph::TypeEnumPb value) {
  
  _impl_.type_enum_ = value;
}
inline void TypeDefPb::set_type_enum(::gs::rpc::graph::TypeEnumPb value) {
  _internal_set_type_enum(value);
  // @@protoc_insertion_point(field_set:gs.rpc.graph.TypeDefPb.type_enum)
}

// repeated .gs.rpc.graph.PropertyDefPb props = 5;
inline int TypeDefPb::_internal_props_size() const {
  return _impl_.props_.size();
}
inline int TypeDefPb::props_size() const {
  return _internal_props_size();
}
inline void TypeDefPb::clear_props() {
  _impl_.props_.Clear();
}
inline ::gs::rpc::graph::PropertyDefPb* TypeDefPb::mutable_props(int index) {
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.TypeDefPb.props)
  return _impl_.props_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::PropertyDefPb >*
TypeDefPb::mutable_props() {
  // @@protoc_insertion_point(field_mutable_list:gs.rpc.graph.TypeDefPb.props)
  return &_impl_.props_;
}
inline const ::gs::rpc::graph::PropertyDefPb& TypeDefPb::_internal_props(int index) const {
  return _impl_.props_.Get(index);
}
inline const ::gs::rpc::graph::PropertyDefPb& TypeDefPb::props(int index) const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.TypeDefPb.props)
  return _internal_props(index);
}
inline ::gs::rpc::graph::PropertyDefPb* TypeDefPb::_internal_add_props() {
  return _impl_.props_.Add();
}
inline ::gs::rpc::graph::PropertyDefPb* TypeDefPb::add_props() {
  ::gs::rpc::graph::PropertyDefPb* _add = _internal_add_props();
  // @@protoc_insertion_point(field_add:gs.rpc.graph.TypeDefPb.props)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gs::rpc::graph::PropertyDefPb >&
TypeDefPb::props() const {
  // @@protoc_insertion_point(field_list:gs.rpc.graph.TypeDefPb.props)
  return _impl_.props_;
}

// string comment = 6;
inline void TypeDefPb::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& TypeDefPb::comment() const {
  // @@protoc_insertion_point(field_get:gs.rpc.graph.TypeDefPb.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypeDefPb::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gs.rpc.graph.TypeDefPb.comment)
}
inline std::string* TypeDefPb::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:gs.rpc.graph.TypeDefPb.comment)
  return _s;
}
inline const std::string& TypeDefPb::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void TypeDefPb::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* TypeDefPb::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* TypeDefPb::release_comment() {
  // @@protoc_insertion_point(field_release:gs.rpc.graph.TypeDefPb.comment)
  return _impl_.comment_.Release();
}
inline void TypeDefPb::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gs.rpc.graph.TypeDefPb.comment)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace graph
}  // namespace rpc
}  // namespace gs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::gs::rpc::graph::TypeEnumPb> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gs::rpc::graph::TypeEnumPb>() {
  return ::gs::rpc::graph::TypeEnumPb_descriptor();
}
template <> struct is_proto_enum< ::gs::rpc::graph::DataTypePb> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gs::rpc::graph::DataTypePb>() {
  return ::gs::rpc::graph::DataTypePb_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_schema_5fcommon_2eproto
