import itertools
from dataclasses import dataclass
import importlib
import logging
import os
from packaging.requirements import Requirement
from pathlib import Path
import sys
from typing import Dict, Any, Optional, List
import yaml

from envzy import AutoExplorer, ModulePathsList

from datasphere.config import PythonEnv as PythonEnvConfig
from datasphere.utils import PythonModule

logger = logging.getLogger(__name__)


@dataclass
class PythonEnv:
    version: str
    local_modules_paths: ModulePathsList
    requirements: List[str]
    pip_options: Optional[PythonEnvConfig.PipOptions] = None

    @property
    def conda_yaml(self) -> str:
        dependencies = [f'python=={self.version}', 'pip']

        requirements = list(self.requirements)  # copy
        if requirements:
            if self.pip_options:
                # Requirements from envzy explorer only contains precise packages versions.
                # User-defined requirements can contain anything supported by pip, so clash with `pip-options`
                # is possible (not solved by now).
                if self.pip_options.extra_index_urls:
                    requirements = [f'--extra-index-url {url}' for url in self.pip_options.extra_index_urls] + \
                                   requirements
                if self.pip_options.trusted_hosts:
                    requirements = [f'--trusted-host {host}' for host in self.pip_options.trusted_hosts] + \
                                   requirements
                if self.pip_options.no_deps:
                    requirements = ['--no-deps'] + requirements
            dependencies.append({'pip': requirements})

        return yaml.dump({'name': 'default', 'dependencies': dependencies}, sort_keys=False)


def define_py_env(root_modules: List[PythonModule], py_env_cfg: PythonEnvConfig) -> PythonEnv:
    version = None
    local_modules_paths = None
    requirements = None

    if not py_env_cfg.is_fully_manual:
        # User may not add cwd to PYTHONPATH, in case of running execution through `datasphere`, not `python -m`.
        # Since path to python script can be only relative, this should always work.
        sys.path.append(os.getcwd())

        extra_index_urls = []
        if py_env_cfg.pip_options and py_env_cfg.pip_options.extra_index_urls:
            extra_index_urls = py_env_cfg.pip_options.extra_index_urls

        explorer = AutoExplorer(extra_index_urls=extra_index_urls)
        version = '.'.join(str(x) for x in explorer.target_python)

        # We can't launch explorer once on namespace merged from multiple modules, because vars from different modules
        # can override each other. So instead we merge explorer artifacts â€“ local modules and requirements.
        local_modules_paths = []
        requirements = []
        for module in root_modules:
            sys.path.append(str(Path(module.path).parent))
            namespace = _get_module_namespace(module)
            local_modules_paths.append(explorer.get_local_module_paths(namespace))
            requirements.append([
                (f'{name}=={version}' if version else name) for name, version in
                explorer.get_pypi_packages(namespace).items()
            ])
            logger.debug('`%s` auto-defined python env:\n\tlocal modules: %s\n\trequirements: %s',
                         module.path, local_modules_paths[-1], requirements[-1])

        def merge(items: List[List[str]]) -> List[str]:
            return list(sorted(set(  # drop duplicates and sort
                itertools.chain(*items)  # flatten
            )))

        local_modules_paths, requirements = merge(local_modules_paths), merge(requirements)

    return PythonEnv(
        version=py_env_cfg.version if py_env_cfg.version else version,
        requirements=_parse_requirements(py_env_cfg.requirements) if py_env_cfg.requirements else requirements,
        local_modules_paths=py_env_cfg.local_modules_paths if py_env_cfg.local_modules_paths else local_modules_paths,
        pip_options=py_env_cfg.pip_options,
    )


main_module_checks = [
    "if __name__ == '__main__':",
    'if __name__ == "__main__":',
]


def _get_module_namespace(module_params: PythonModule) -> Dict[str, Any]:
    if module_params.is_name:
        module = importlib.import_module(module_params.path)
    else:
        # User scripts shouldn't execute any code in global namespace (only imports and declarations) and should contain
        # `if __name__ == '__main__'` check in main module, otherwise on module import user program will start to
        # execute, but we only want to collect global namespace.
        # If user does it anyway, there is no straightforward and cross-platform way to import module with timeout, in
        # case if some long-running calculations will start.
        # CLI commands, generated by setup.py `entry_points`, also have main module check.
        # TODO: root module launched with multiprocessing will have different name, not '__main__'
        #   this is an exotic use-case, fix this if such use-case will appear on practice
        code_lines = Path(module_params.path).read_text().split('\n')
        has_main_module_check = any(
            any(line.startswith(check) for check in main_module_checks)
            for line in code_lines
        )
        if not has_main_module_check:
            raise ValueError(f'Main script `{module_params.path}` must have line `{main_module_checks[0]}`')
        module_spec = importlib.util.spec_from_file_location('module', module_params.path)
        if module_spec is None:
            raise ValueError(f'Main script `{module_params.path}` can\'t be loaded by importlib')
        module = importlib.util.module_from_spec(module_spec)
        module_spec.loader.exec_module(module)
    return vars(module)


# Allow packages specifiers (with extras) and flags/options (supported by server).
def _parse_requirements(f: Path) -> List[str]:
    lines = [line.strip() for line in f.read_text().strip().split('\n') if line.strip()]
    for line in lines:
        if line == '--no-deps':
            continue
        if line.startswith('--extra-index-url'):
            continue
        if line.startswith('--trusted-host'):
            continue
        req = Requirement(line)
        if req.marker:
            raise ValueError(f'requirement markers are not supported ({line})')
        if req.url:
            raise ValueError(f'requirement url is not supported ({line})')
    return lines
