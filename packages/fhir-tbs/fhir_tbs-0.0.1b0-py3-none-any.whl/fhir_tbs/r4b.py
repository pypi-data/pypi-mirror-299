from collections.abc import AsyncGenerator
from typing import Any

import fhirpy_types_r4b as r4b
from aiohttp import web
from fhirpy import AsyncFHIRClient
from fhirpy.base.utils import encode_params

from .implementation import SubscriptionEvent, SubscriptionInfo, tbs_ctx_factory
from .types import SubscriptionDefinition


def r4b_tbs_ctx_factory(
    app: web.Application,
    app_url: str,
    webhook_path_prefix: str,
    fhir_client: AsyncFHIRClient,
    subscriptions: list[SubscriptionDefinition],
) -> AsyncGenerator[None, None]:
    return tbs_ctx_factory(
        app,
        app_url,
        webhook_path_prefix,
        fhir_client,
        subscriptions,
        _fetch_subscription=r4b_fetch_subscription,
        _fetch_subscription_events=r4b_fetch_subscription_events,
        _build_subscription=r4b_build_subscription,
        _extract_subscription_info=r4b_extract_subscription_info,
        _extract_subscription_events_from_bundle=r4b_extract_subscription_events_from_bundle,
    )


async def r4b_fetch_subscription(
    fhir_client: AsyncFHIRClient, webhook_url: str
) -> r4b.Subscription | None:
    return await fhir_client.resources(r4b.Subscription).search(url=webhook_url).first()


async def r4b_fetch_subscription_events(
    fhir_client: AsyncFHIRClient,
    subscription: r4b.Subscription,
    since: int | None,
    until: int | None,
) -> list[SubscriptionEvent]:
    bundle_data = await fhir_client.execute(
        f"Subscription/{subscription.id}/$events",
        method="GET",
        params={"eventsSinceNumber": since, "eventsUntilNumber": until},
    )
    return r4b_extract_subscription_events_from_bundle(bundle_data)


def r4b_extract_subscription_info(subscription: r4b.Subscription) -> SubscriptionInfo:
    token = None
    headers = subscription.channel.header or []
    for header in headers:
        if header.lower().startswith("x-api-key"):
            token = header.split(":", 1)[1].strip()

    return {"status": subscription.status, "token": token}


def r4b_extract_subscription_events_from_bundle(
    bundle_data: dict,
) -> list[SubscriptionEvent]:
    notification_bundle = r4b.Bundle(**bundle_data)
    assert notification_bundle.entry
    assert notification_bundle.entry[0]
    assert notification_bundle.entry[0].resource
    subscription_status = notification_bundle.entry[0].resource
    assert isinstance(subscription_status, r4b.SubscriptionStatus)

    return [
        {
            "reference": event.focus.reference,
            "timestamp": event.timestamp,
            "event_number": int(event.eventNumber),
        }
        for event in (subscription_status.notificationEvent or [])
        if event.focus and event.focus.reference
    ]


def r4b_build_subscription(
    name: str, webhook_url: str, token: str, subscription: SubscriptionDefinition
) -> r4b.Subscription:
    return r4b.Subscription(
        meta=r4b.Meta(
            profile=[
                "http://hl7.org/fhir/uv/subscriptions-backport/StructureDefinition/backport-subscription"
            ]
        ),
        reason=f"Autogenerated subscription for {name}",
        status="requested",
        channel=r4b.SubscriptionChannel(
            payload="application/fhir+json",
            payload__ext=r4b.Element(
                extension=[
                    r4b.Extension(
                        url="http://hl7.org/fhir/uv/subscriptions-backport/StructureDefinition/backport-payload-content",
                        valueCode="id-only",
                    )
                ],
            ),
            type="rest-hook",
            endpoint=webhook_url,
            header=[f"X-Api-Key: {token}"],
            extension=[
                # maxCount must be 1
                r4b.Extension(
                    url="http://hl7.org/fhir/uv/subscriptions-backport/StructureDefinition/backport-max-count",
                    valuePositiveInt=1,
                ),
                r4b.Extension(
                    url="http://hl7.org/fhir/uv/subscriptions-backport/StructureDefinition/backport-heartbeat-period",
                    valuePositiveInt=20,
                ),
                r4b.Extension(
                    url="http://hl7.org/fhir/uv/subscriptions-backport/StructureDefinition/backport-timeout",
                    valuePositiveInt=60,
                ),
            ],
        ),
        criteria=subscription["topic"],
        criteria__ext=r4b.Element(
            extension=[
                r4b.Extension(
                    url="http://hl7.org/fhir/uv/subscriptions-backport/StructureDefinition/backport-filter-criteria",
                    valueString=_build_filter_criteria(subscription),
                )
            ],
        ),
    )


def _build_filter_criteria(subscription: SubscriptionDefinition) -> str:
    params: dict[str, Any] = {}

    resource_type = None

    for f in subscription["filterBy"]:
        if not resource_type:
            resource_type = f["resourceType"]
        elif resource_type != f["resourceType"]:
            raise NotImplementedError("Only one resource type is supported for filters")

        param_name = f["filterParameter"]
        if "modifier" in f:
            param_name = f'{f["filterParameter"]}:{f['modifier']}'
        param_value = f["value"]
        if "comparator" in f:
            param_value = f'{f["comparator"]}{f["value"]}'

        params[param_name] = param_value

    if not resource_type:
        raise TypeError("At least one filterBy is required for AidboxSubscription")

    return f"{resource_type}?{encode_params(params)}"
