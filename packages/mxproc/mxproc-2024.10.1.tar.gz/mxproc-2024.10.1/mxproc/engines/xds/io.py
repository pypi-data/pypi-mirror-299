from __future__ import annotations

import os
import shutil
from pathlib import Path
from dataclasses import dataclass, field
from typing import Union, Literal, Tuple, Sequence

import numpy

from mxproc.xtal import Lattice, Experiment
from mxproc.common import find_missing
from mxio import XYPair


XDSJob = Literal["XYCORR", "INIT", "COLSPOT", "IDXREF",  "XPLAN", "DEFPIX", "INTEGRATE", "CORRECT", "ALL"]
XDSRefinement = Literal["CELL", "BEAM", "ORIENTATION", "AXIS",  "DISTANCE", "POSITION", "SEGMENT", "ALL"]


@dataclass
class JobParameters:
    mode: Literal["SLURM", "SSH", "LOCAL"] = "LOCAL"
    nodes: int | None = None
    cpus: int | None = None
    host: str | None = None
    tasks: int | None = None
    partition: str | None = None


@dataclass
class XDSParameters:
    data_range: Sequence[Tuple[int, int]]
    spot_range: Sequence[Tuple[int, int]]

    format: str = ""
    beam_center: XYPair | None = None
    lattice: Lattice = field(default_factory=Lattice)
    reindex: Sequence[int] | None = None
    reference: Path | None = None
    plugin: str | None = None

    resolution_limit: float = 0.0

    min_fraction: float | None = None
    spot_separation: float = 1.0
    spot_size: float = 1.0
    error_scale: float | None = None

    strong_sigma: int | None = 1
    anomalous: bool = False
    strict_absorption: bool = False
    fixed_scale_factors: bool = False
    invert_spindle: bool = False

    # Integration optimisation options
    divergence: float | None = None
    divergence_esd: float | None = None
    refl_range: float | None = None
    refl_range_esd: float | None = None

    message: str = ""
    refine_index: Sequence[XDSRefinement] = ('CELL', 'BEAM', 'ORIENTATION', 'AXIS')
    refine_integrate: Sequence[XDSRefinement] = ('POSITION', 'BEAM', 'ORIENTATION')

    cluster: dict = field(default_factory=dict)


def create_input_file(jobs: Sequence[XDSJob], experiment: Experiment, parameters: XDSParameters) -> JobParameters:
    """
    Create an XDS.INP input file

    :param jobs: a sequence of XDS Job keys
    :param experiment: Experiment instance
    :param parameters: The parameters to be used when creating the file.
    """

    detector_name = experiment.detector.upper()
    parameters.format = experiment.format

    # Default parameters
    max_angle_error: float = 2.0
    max_pixel_error: float = 3.0
    spot_size_pixels: float = 6.0
    spot_gap_pixels: float = 7.0

    job_pars = {}

    if 'ADSC' in detector_name:
        detector_type = 'ADSC'
    elif 'RAYONIX' in detector_name:
        detector_type = 'CCDCHESS'
    elif 'RAXIS' in detector_name:
        detector_type = 'RAXIS'
    elif 'PILATUS' in detector_name:
        detector_type = 'PILATUS'
        spot_gap_pixels = 2
    elif 'EIGER' in detector_name:
        detector_type = 'EIGER'
        spot_gap_pixels = 3
    else:
        detector_type = 'CCDCHESS'

    # if parameters.format == 'CBF':
    #    parameters.plugin = shutil.which('xds-zcbf.so')
    if experiment.format == "NXmx":
        parameters.plugin = shutil.which('durin-plugin.so')
    elif parameters.format == "HDF5":
        parameters.plugin = shutil.which('dectris-neggia.so')

    if parameters.plugin:
        parameters.format = "GENERIC"

    jobs_flag = " ".join(jobs)
    friedel_flag = {True: 'FALSE', False: 'TRUE'}[parameters.anomalous]
    template_path = experiment.directory / experiment.template

    job_text = (
        f"!- XDS.INP ----------- Generated by MX Process\n"
        f"JOB=   {jobs_flag}\n"
    )
    if parameters.cluster:
        job_pars.update(**parameters.cluster)
        delphi = 5.0
        cpus = parameters.cluster["cpus"] // (2 * (2 ** numpy.arange(3)))
        batch_size = delphi / experiment.delta_angle
        max_cpu = cpus[numpy.abs(cpus - batch_size).argmin()]
        max_jobs = parameters.cluster["nodes"] * parameters.cluster["cpus"] // max_cpu
        delphi = max_cpu * experiment.delta_angle

        job_text += f"MAXIMUM_NUMBER_OF_JOBS={max_jobs}\n"
        job_text += f"MAXIMUM_NUMBER_OF_PROCESSORS={max_cpu}\n"
        job_text += f"DELPHI={delphi:0.2f}\n"

        job_pars.update(cpus=max_cpu, tasks=max_jobs)

    dataset_text = (
        f"!------------------- Dataset parameters\n"
        f"X-RAY_WAVELENGTH=  {experiment.wavelength:7.5f}\n"
        f"DETECTOR_DISTANCE= {experiment.distance:5.1f}\n"
        f"STARTING_ANGLE=    {experiment.start_angle:5.1f}\n"
        f"STARTING_FRAME=    {parameters.data_range[0][0]}\n"
        f"OSCILLATION_RANGE= {experiment.delta_angle:4.2f}\n"
        f"FRIEDEL'S_LAW= {friedel_flag}\n"
        f"NAME_TEMPLATE_OF_DATA_FRAMES={template_path} {parameters.format}\n"
        f"DATA_RANGE=    {parameters.data_range[0][0]} {parameters.data_range[-1][1]-1}\n"
    )
    for start, end in parameters.spot_range:
        dataset_text += f"SPOT_RANGE=    {start} {end-1}\n"

    for start, end in find_missing(parameters.data_range):
        dataset_text += f"EXCLUDE_DATA_RANGE=    {start} {end-1}\n"

    # Allow injecting an external library for reading dataset files
    if parameters.plugin is not None:
        dataset_text += f'LIB= {parameters.plugin}\n'

    if parameters.lattice.spacegroup > 0:
        # space group and cell parameters
        dataset_text += (
            f"SPACE_GROUP_NUMBER=  {parameters.lattice.spacegroup}\n"
            f"UNIT_CELL_CONSTANTS= {parameters.lattice.a:0.3f} {parameters.lattice.b:0.3f} {parameters.lattice.c:0.3f} "
            f"{parameters.lattice.alpha:0.3f} {parameters.lattice.beta:0.3f} {parameters.lattice.gamma:0.3f}\n"
        )

        # reindexing matrix
        if parameters.reindex is not None:
            dataset_text += "REIDX= {} {} {} {} {} {} {} {} {} {} {} {}\n".format(*parameters.reindex)

    # reference data
    if parameters.reference is not None and parameters.reference.exists():
        dataset_text += f"REFERENCE_DATA_SET=  {parameters.reference}\n"

    beam_axis = experiment.geometry.beam
    det_xaxis = experiment.geometry.detector[0]
    det_yaxis = experiment.geometry.detector[1]
    mult = -1 if parameters.invert_spindle else 1
    rot_axis = tuple(numpy.array(experiment.geometry.goniometer) * mult)

    # override detector origin if provided
    origin = experiment.detector_origin if parameters.beam_center is None else parameters.beam_center
    beamline_text = (
        "!----------------- Beamline parameters\n"
        f"DETECTOR= {detector_type}\n"
        f"NX={experiment.detector_size.x}   NY= {experiment.detector_size.y}\n"
        f"QX={experiment.pixel_size.x:7.5f} QY={experiment.pixel_size.y:7.5f}\n"
        f"ORGX={origin.x:5.0f}  ORGY={origin.y:5.0f}\n"
        f"SENSOR_THICKNESS= {experiment.sensor_thickness:0.3f}\n"
        f"OVERLOAD= {experiment.cutoff_value}\n"
        # f"SIGNAL_PIXEL= {parameters.strong_sigma:0.1f} ! NOTE: SPOT.XDS managed externally \n"
        "TRUSTED_REGION=0.00 1.2\n"
        f"TEST_RESOLUTION_RANGE= 50.0 {max(1.0, parameters.resolution_limit):0.2f}\n"
        "TOTAL_SPINDLE_ROTATION_RANGES= 30 180 30\n"
        "STARTING_ANGLES_OF_SPINDLE_ROTATION= 0 180 15\n"
        "VALUE_RANGE_FOR_TRUSTED_DETECTOR_PIXELS= 6000 30000\n"
        f"INCLUDE_RESOLUTION_RANGE=50.0 {parameters.resolution_limit:0.2f}\n"
        "FRACTION_OF_POLARIZATION=0.99\n"
        "POLARIZATION_PLANE_NORMAL= 0.0 1.0 0.0\n"
        f"ROTATION_AXIS= {rot_axis[0]:0.3f} {rot_axis[1]:0.3f} {rot_axis[2]:0.3f}\n"
        f"INCIDENT_BEAM_DIRECTION= {beam_axis[0]:0.3f} {beam_axis[1]:0.3f} {beam_axis[2]:0.3f}\n"
        f"DIRECTION_OF_DETECTOR_X-AXIS= {det_xaxis[0]:0.3f} {det_xaxis[1]:0.3f} {det_xaxis[2]:0.3f}\n"
        f"DIRECTION_OF_DETECTOR_Y-AXIS= {det_yaxis[0]:0.3f} {det_yaxis[1]:0.3f} {det_yaxis[2]:0.3f}\n"
    )

    extra_text = "!----------------- Extra parameters\n"
    if 'PILATUS' in detector_name or 'EIGER' in detector_name:
        extra_text += "NUMBER_OF_PROFILE_GRID_POINTS_ALONG_ALPHA/BETA= 13\n"

    if parameters.spot_separation > 0:
        min_sep = round(parameters.spot_separation * spot_gap_pixels)
        extra_text += f'SEPMIN= {min_sep:0.1f}\n'
        extra_text += f'CLUSTER_RADIUS= {min_sep/2:0.1f}\n'

    if parameters.spot_size > 0:
        extra_text += f'MINIMUM_NUMBER_OF_PIXELS_IN_A_SPOT= {spot_size_pixels * parameters.spot_size:0.0f}\n'

    if parameters.min_fraction is not None:
        extra_text += f'MINIMUM_FRACTION_OF_INDEXED_SPOTS= {parameters.min_fraction:0.1f}\n'

    if parameters.strict_absorption:
        extra_text += 'STRICT_ABSORPTION_CORRECTION= TRUE\n'

    if parameters.refine_index:
        refine_flags = ' '.join(parameters.refine_index)
        extra_text += f'REFINE(IDXREF)= {refine_flags}\n'

    if parameters.refine_integrate:
        refine_flags = ' '.join(parameters.refine_integrate)
        extra_text += f'REFINE(INTEGRATE)= {refine_flags}\n'

    if parameters.fixed_scale_factors:
        extra_text += f'DATA_RANGE_FIXED_SCALE_FACTOR= {parameters.data_range[0]} {parameters.data_range[1]} 1.0\n'

    if parameters.error_scale is not None:
        extra_text += f'MAXIMUM_ERROR_OF_SPOT_POSITION= {parameters.error_scale * max_pixel_error:0.1f}\n'
        extra_text += f'MAXIMUM_ERROR_OF_SPINDLE_POSITION= {parameters.error_scale * max_angle_error:0.1f}\n'
        extra_text += f'INDEX_ERROR= {parameters.error_scale * 0.05: 0.1f}\n'

    if all((parameters.refl_range, parameters.divergence, parameters.refl_range_esd, parameters.divergence_esd)):
        extra_text += (
            f'BEAM_DIVERGENCE=   {parameters.divergence}\n'
            f'BEAM_DIVERGENCE_E.S.D.=   {parameters.divergence_esd}\n'
            f'REFLECTING_RANGE=  {parameters.refl_range}\n'
            f'REFLECTING_RANGE_E.S.D.=  {parameters.refl_range_esd}\n'
        )

    with open('XDS.INP', 'w') as outfile:
        outfile.write(job_text)
        outfile.write(dataset_text)
        outfile.write(beamline_text)
        outfile.write(extra_text)

    return JobParameters(**job_pars)


def save_spots():
    """
    Make a backup of SPOT.XDS in numpy format to be used for indexing
    """

    spots = numpy.loadtxt('SPOT.XDS')
    numpy.save('spots', spots)


SPOT_COLUMN_FORMATS = {
    5: ["%0.2f", "%0.2f", "%0.2f", "%0.2f", "%d"],
    4: ["%0.2f", "%0.2f", "%0.2f", "%0.2f"],
    7: ["%0.2f", "%0.2f", "%0.2f", "%0.2f", "%d", "%d", "%d"],
    8: ["%0.2f", "%0.2f", "%0.2f", "%0.2f", "%d", "%d", "%d", "%d"],
}


def filter_spots(
        min_sigma: Union[float, None] = None,
        max_sigma: Union[float, None] = None,
        exclude_frames: Tuple = (),
):
    """
    Create a SPOT.XDS file from a spots.hkl file filtering based on several parameters
    :param min_sigma: select spots with sigma higher than this value
    :param max_sigma: select spots with sigma lower than this value
    :param exclude_frames:  Exclude spots from specified frames
    """

    spots = numpy.load('spots.npy')
    selected = numpy.ones_like(spots[:, 0]).astype(bool)
    sigma = spots[:, 3]
    num_columns = len(spots[0])
    frames = numpy.round(spots[:, 2]).astype(int)

    # if min_sigma is not None:
    #     selected &= sigma > (min_sigma + 2)
    # if max_sigma is not None:
    #     selected &= sigma < max_sigma

    excluded = (frames < 0)   # start with none excluded
    for start, end in exclude_frames:
        excluded |= ((frames >= start) & (frames <= end))

    if excluded.sum():
        selected &= ~excluded

    numpy.savetxt("SPOT.XDS", spots[selected, :], fmt=SPOT_COLUMN_FORMATS[num_columns])


def write_xscale_input(params: Sequence[dict], cluster: dict = None, **kwargs) -> JobParameters:
    """
    Generate an XSCALE.INP input file from a parameter list
    :param cluster: cluster parameter dictionary or None
    :param params: sequence of dictionaries, one for each scaled output file

    params = [ {
            'reindex_matrix': tuple of 12 ints, optional
            'space_group': int, optional
            'unit_cell': tuple of 6 floats, optional
            'anomalous': bool
            'output_file': str
            'crystal': str
            'inputs': list of [{'input_file': str, 'resolution': float, 'reference':bool}]
        }]
    """

    header = "!-XSCALE.INP--------File generated by auto.process \n"
    body = ""
    shells = []
    friedel = 'FALSE' if params[0].get('anomalous') else 'TRUE'

    for i, section in enumerate(params):
        body += f"OUTPUT_FILE= {section['output_file']}\n"
        body += f"FRIEDEL'S_LAW={friedel}\n"
        if section.get('reindex_matrix'):
            matrix = ' '.join([f'{x:02d}' for x in section.get('reindex_matrix')])
            body += f"REIDX= {matrix}\n"
        if section.get('space_group') and section.get('unit_cell'):
            cell_text = ' '.join([f'{x:02d}' for x in section['unit_cell']])
            body += f"SPACE_GROUP_NUMBER= {section['space_group']:d} \n"
            body += f"UNIT_CELL_CONSTANTS= {cell_text}"

        if i == 0:
            shells = section.get('shells')
        elif section.get('shells')[-1] < shells[-1]:
            shells = section.get('shells')

        for section_input in section['inputs']:
            star = '*' if section_input.get('reference', False) else ' '
            body += f"INPUT_FILE={star}{section_input['input_file']} \n"
            body += f"INCLUDE_RESOLUTION_RANGE= 50 {section_input['resolution']:5.2f}\n"
            if section.get('crystal'):
                body += f"CRYSTAL_NAME={section['crystal']}\n"

    if len(shells):
        shells_text = ' '.join([f'{x:0.2f}' for x in shells])
        header += f'RESOLUTION_SHELLS= {shells_text}\n'

    file_text = header + body + "!-------------------File generated by auto.process \n"
    with open('XSCALE.INP', 'w') as outfile:
        outfile.write(file_text)
    if cluster:
        return JobParameters(**cluster)
    return JobParameters()


def write_xdsconv_input(params: dict) -> JobParameters:
    """
    Write an XDSCONV.INP file for converting reflections
    :param params: parameters in a dictionary

    params = {
        'anomalous': bool
        'format' : str
        'input_file': str
        'prefix' : str
        'free_r': float 0.0 < x < 1.0
    }
    """
    if params['format'] == 'MTZ':
        format_flag = 'CCP4_I+F'
        suffix = 'ccp4'
    else:
        format_flag = params['format']
        suffix = format_flag.lower()

    friedel_flag = {True: 'FALSE', False: 'TRUE'}[params.get('anomalous', False)]

    file_text = "!-XDSCONV.INP--------File generated by auto.process \n"
    file_text += f"INPUT_FILE= {params['input_file']}  XDS_ASCII\n"
    file_text += f"OUTPUT_FILE={params['prefix']}-{suffix}.hkl {format_flag}\n"
    file_text += f"FRIEDEL'S_LAW={friedel_flag}\n"
    file_text += "MERGE=FALSE\n"
    if params.get('free_r', 0.0) > 0.0:
        file_text += f"GENERATE_FRACTION_OF_TEST_REFLECTIONS={params['free_r']:0.2f}\n"
    file_text += "!-------------------File generated by auto.process \n"

    with open('XDSCONV.INP', 'w') as outfile:
        outfile.write(file_text)

    return JobParameters()
